#include "utils.h"




STATIC CONST UINT8 SigOslFwpKernelSetupPhase1[] = {
	0x89, 0xCC, 0x24, 0x01, 0x00, 0x00,				// mov [REG+124h], r32
	0xE8, 0xCC, 0xCC, 0xCC, 0xCC,					// call BlBdStop
	0xCC, 0x8B, 0xCC								// mov r32, r/m32
};



EFI_EXIT_BOOT_SERVICES OriginalExitBootServices = NULL;

EFI_SYSTEM_TABLE *GlobalSystemTable = NULL;

VOID *OriginalOslArchTransferToKernelAddr = NULL;

UINT8 original_osl_transfer_bytes[0x30] = {0};

VOID* winload_base = NULL;

UINTN OslFunctionOffset = 0;


// mega dummy function, it will be written 
VOID EFIAPI OslArchTransferToKernelCallGate(IN VOID* LoaderBlock, IN VOID* Entry ) {
    int a = 0x69420;
    return;
}


__attribute__((optimize("-O2")))
VOID EFIAPI OslArchTransferToKernelHook (IN PLOADER_PARAMETER_BLOCK LoaderBlock, IN VOID *Entry)
{

    
    // simply call the callgate
    ((VOID (*)(VOID *, VOID *))OslArchTransferToKernelCallGate)(LoaderBlock, Entry);
}



VOID EFIAPI OslFwpKernelSetupPhase1CallGate(IN VOID* LoaderBlock, IN VOID* Entry ) {
    int a = 0x69420;
    return;
}


__attribute__((optimize("-O2")))
VOID EFIAPI OslFwpKernelSetupPhase1Hook (IN PLOADER_PARAMETER_BLOCK LoaderBlock, IN VOID *Entry)
{

    // simply call the callgate
    ((VOID (*)(VOID *, VOID *))OslFwpKernelSetupPhase1CallGate)(LoaderBlock, Entry);
}





// Hook function for ExitBootServices
EFI_STATUS EFIAPI ExitBootServicesHook(IN EFI_HANDLE ImageHandle, IN UINTN MapKey) {
    EFI_STATUS Status;
    VOID *OslArchTransferToKernelAddr;
    VOID *ReturnAddr;
    VOID *OslFwpKernelSetupPhase1;

    
    // Here you can add your custom logic before exiting boot services
    Print(L"[HOOK] ExitBootServices called!\n");
    Print(L"[HOOK] ImageHandle: 0x%lx, MapKey: 0x%lx\n", ImageHandle, MapKey);
    
    // Get return address
    ReturnAddr = GetReturnAddress();
    Print(L"[HOOK] Return address: 0x%lx\n", (UINTN)ReturnAddr);
    
    // Try to find OslArchTransferToKernel using the return address
    Print(L"[HOOK] Searching for OslArchTransferToKernel...\n");
    OslArchTransferToKernelAddr = FindOslArchTransferToKernel(ReturnAddr);
    // __builtin_memcpy(OriginalOslArchTransferToKernelAddr, OslArchTransferToKernelAddr, 0x8);
    OriginalOslArchTransferToKernelAddr = OslArchTransferToKernelAddr;

    UINT8* Found = NULL;

    FindPattern(SigOslFwpKernelSetupPhase1, 0xCC, sizeof(SigOslFwpKernelSetupPhase1), (VOID*)winload_base, 0x100000, (VOID**)&Found);
    if (Found != NULL) {
        OslFwpKernelSetupPhase1 = Found;
        Print(L"[HOOK] Found OslFwpKernelSetupPhase1 at: 0x%lx\n", (UINTN)OslFwpKernelSetupPhase1);
    } else {
        OslFwpKernelSetupPhase1 = NULL;
    }

    
    VOID* OslFwpKernelSetupPhase1Base = FindOslFwpKernelSetupPhase1Base(OslFwpKernelSetupPhase1);

    if (OslFwpKernelSetupPhase1Base != NULL) {
        Print(L"[HOOK] OslFwpKernelSetupPhase1Base found at: 0x%lx\n", (UINTN)OslFwpKernelSetupPhase1Base);
    } else {
        Print(L"[HOOK] OslFwpKernelSetupPhase1Base not found\n");
    }

    UINT16 OslFwpOffset = (UINTN)OslFwpKernelSetupPhase1 - (UINTN)OslFwpKernelSetupPhase1Base;

    Print(L"[HOOK] OslFwpKernelSetupPhase1 offset: 0x%x\n", OslFwpOffset);




    if (OslArchTransferToKernelAddr != NULL) {
        Print(L"[HOOK] Found OslArchTransferToKernel at: 0x%lx\n", (UINTN)OslArchTransferToKernelAddr);
        // You can now hook this function or perform other actions
    } else {
        Print(L"[HOOK] OslArchTransferToKernel not found\n");
    }


    *(UINT16*)(OslFwpKernelSetupPhase1Base + 0x00) = (UINT16)0x25FF; // jmp far
    *(UINT32*)(OslFwpKernelSetupPhase1Base + 0x02) = (UINT32)0x00; // segment selector (0x00 for kernel)
    *(UINT64*)(OslFwpKernelSetupPhase1Base + 0x06) = (UINT64)OslFwpKernelSetupPhase1Hook; // address of the hook function

    Print(L"[HOOK] OslFwpKernelSetupPhase1 hooked successfully!\n");

    UINT8 original_osl_fwp_bytes[0x100] = {0};
    __builtin_memcpy(original_osl_fwp_bytes, OslFwpKernelSetupPhase1, 0x100);

    *(UINT16*)(OslFwpKernelSetupPhase1CallGate + OslFwpOffset + 0x00) = (UINT16)0x25FF; // jmp far
    *(UINT32*)(OslFwpKernelSetupPhase1CallGate + OslFwpOffset + 0x02) = (UINT32)0x00; // segment selector (0x00 for kernel)
    *(UINT64*)(OslFwpKernelSetupPhase1CallGate + OslFwpOffset + 0x06) = (UINT64)(OslFwpKernelSetupPhase1Base) + OslFwpOffset; // address of the original function




    // hook the OslArchTransferToKernel function

    *(UINT16*)(OslArchTransferToKernelAddr + 0x00) = (UINT16)0x25FF;
    *(UINT32*)(OslArchTransferToKernelAddr + 0x02) = (UINT32)0x00;
    *(UINT64*)(OslArchTransferToKernelAddr + 0x06) = (UINT64)OslArchTransferToKernelHook;
    //*(UINT64*)(OslArchTransferToKernelAddr + 0x06) = (UINT64)OslArchTransferToKernelCallGate;


    Print(L"[HOOK] OslArchTransferToKernel hooked successfully!\n");

    Print(L"[HOOK] OslArchTranferToKernel at : 0x%lx  Now\n", (UINTN)OslArchTransferToKernelAddr);
    for (UINTN i = 0; i < 0x30; i++) {
        Print(L"%02x ", ((UINT8*)OslArchTransferToKernelAddr)[i]);
    }
    __builtin_memcpy(OslArchTransferToKernelCallGate, original_osl_transfer_bytes, OslFunctionOffset);

    *(UINT16*)(OslArchTransferToKernelCallGate + OslFunctionOffset + 0x00) = (UINT16)0x25FF;
    *(UINT32*)(OslArchTransferToKernelCallGate + OslFunctionOffset + 0x02) = (UINT32)0x00;
    *(UINT64*)(OslArchTransferToKernelCallGate + OslFunctionOffset + 0x06) = (UINT64)(OriginalOslArchTransferToKernelAddr) + OslFunctionOffset;

    Print(L"[HOOK] OslArchTransferToKernelHook  at: 0x%lx\n", (UINTN)OslArchTransferToKernelHook);
    Print(L"[HOOK] OslArchTransferToKernelCallGate at: 0x%lx  Now\n", (UINTN)OslArchTransferToKernelCallGate);
    for (UINTN i = 0; i < 0x30; i++) {
        Print(L"%02x ", ((UINT8*)OslArchTransferToKernelCallGate)[i]);
    }

    
    // Call the original ExitBootServices
    if (OriginalExitBootServices != NULL) {
        Print(L"[HOOK] Calling original ExitBootServices...\n");
        return OriginalExitBootServices(ImageHandle, MapKey);
        Print(L"[HOOK] Original ExitBootServices returned: 0x%lx\n", Status);
    } else {
        Print(L"[HOOK] ERROR: Original ExitBootServices is NULL!\n");
        Status = EFI_UNSUPPORTED;
    }
    
    return Status;
}

EFI_STATUS EFIAPI efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS Status;
    EFI_INPUT_KEY Key;
    UINTN Index;
    
    // Initialize the library
    InitializeLib(ImageHandle, SystemTable);
    
    // Save system table globally
    GlobalSystemTable = SystemTable;
    
    // Clear screen
    uefi_call_wrapper(SystemTable->ConOut->ClearScreen, 1, SystemTable->ConOut);
    
    // Print Hello World
    Print(L"Hello World from UEFI!\n");
    
    // Optional: Wait for a keypress (comment out for automatic boot)
    Print(L"Press any key to continue boot...\n");
    uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3, 1, &SystemTable->ConIn->WaitForKey, &Index);
    uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2, SystemTable->ConIn, &Key);

    // Hook ExitBootServices
    Print(L"Installing ExitBootServices hook...\n");
    
    // Save the original ExitBootServices pointer
    OriginalExitBootServices = SystemTable->BootServices->ExitBootServices;
    Print(L"Original ExitBootServices at: 0x%lx\n", (UINTN)OriginalExitBootServices);
    
    // Replace with our hook
    SystemTable->BootServices->ExitBootServices = ExitBootServicesHook;
    Print(L"Hook installed at: 0x%lx\n", (UINTN)ExitBootServicesHook);
    
    // Try to load the next stage bootloader
    // First try bootmgfw.efi (Windows Boot Manager)
    Print(L"Attempting to load Bootmgfw...\n");

    Status = SetVbsPolicyDisable(SystemTable);
    if (EFI_ERROR(Status)) {
        Print(L"[VBS] Failed to set VbsPolicyDisable, continuing anyway...\n");
    } else {
        Print(L"[VBS] VbsPolicyDisable set successfully.\n");
    }
    Status = LoadAndExecuteImage(ImageHandle, SystemTable, L"\\EFI\\Microsoft\\Boot\\bootmgfw-orig.efi");

    if (EFI_ERROR(Status)) {
        Print(L"ERROR: Failed to load bootmgfw.efi (0x%lx),\n", Status);

    }
    
    // If we reach this point, we failed to load any bootloader
    if (EFI_ERROR(Status)) {
        Print(L"Failed to load any bootloader. System halted.\n");
        Print(L"Press any key to shutdown...\n");
        uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3, 1, &SystemTable->ConIn->WaitForKey, &Index);
        uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2, SystemTable->ConIn, &Key);
        
        // Restore original ExitBootServices before returning
        if (OriginalExitBootServices != NULL) {
            SystemTable->BootServices->ExitBootServices = OriginalExitBootServices;
        }
    }
    
    return Status;
}