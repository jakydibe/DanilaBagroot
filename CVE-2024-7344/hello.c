#include "utils.h"


char ErrorString[256] = {0};



STATIC CONST UINT8 SigOslFwpKernelSetupPhase1[] = {
	0x89, 0xCC, 0x24, 0x01, 0x00, 0x00,				// mov [REG+124h], r32
	0xE8, 0xCC, 0xCC, 0xCC, 0xCC,					// call BlBdStop
	0xCC, 0x8B, 0xCC								// mov r32, r/m32
};



EFI_EXIT_BOOT_SERVICES OriginalExitBootServices = NULL;

EFI_IMAGE_LOAD OriginalLoadImage = NULL;

EFI_SYSTEM_TABLE *GlobalSystemTable = NULL;

VOID *OriginalOslArchTransferToKernelAddr = NULL;

UINT8 original_osl_transfer_bytes[0x30] = {0};
UINT8 original_img_arch_bytes[0x30] = {0};

VOID* winload_base = NULL;

VOID* BootmgfwBase = NULL;
UINT32 BootmgfwSize = 0;

UINTN OslFunctionOffset = 0;

// mega dummy function, it will be written 
VOID EFIAPI OslArchTransferToKernelCallGate(IN VOID* LoaderBlock, IN VOID* Entry ) {
    int a = 0x69420;
    return;
}


__attribute__((optimize("-O2")))
VOID EFIAPI OslArchTransferToKernelHook (IN PLOADER_PARAMETER_BLOCK LoaderBlock, IN VOID *Entry)
{

    ((VOID (*)(VOID *, VOID *))OslArchTransferToKernelCallGate)(LoaderBlock, Entry);
}



VOID EFIAPI OslFwpKernelSetupPhase1CallGate(IN VOID* LoaderBlock, IN VOID* Entry ) {
    int a = 0x69420;
    return;
}


__attribute__((optimize("-O2")))
VOID EFIAPI OslFwpKernelSetupPhase1Hook (IN PLOADER_PARAMETER_BLOCK LoaderBlock, IN VOID *Entry)
{
    // Print(L"[HOOK] OslFwpKernelSetupPhase1Hook called!\n");
    // simply call the callgate
    ((VOID (*)(VOID *, VOID *))OslFwpKernelSetupPhase1CallGate)(LoaderBlock, Entry);
}



// __attribute__((optimize("-O2")))
EFI_STATUS EFIAPI __attribute__((ms_abi)) ImgArchStartBootApplicationCallGate (IN PBL_APPLICATION_ENTRY AppEntry,
	IN VOID* ImageBase,
	IN UINT32 ImageSize,
	IN UINT32 BootOption,
	OUT PBL_RETURN_ARGUMENTS ReturnArguments
	) {
    int a = 0x69420;
    return EFI_SUCCESS;
}

__attribute__((optimize("-O2")))
EFI_STATUS EFIAPI __attribute__((ms_abi)) ImgArchStartBootApplicationHook (IN PBL_APPLICATION_ENTRY AppEntry,
	IN VOID* ImageBase,
	IN UINT32 ImageSize,
	IN UINT32 BootOption,
	OUT PBL_RETURN_ARGUMENTS ReturnArguments
	)
{

    EFI_INPUT_KEY Key;
    UINTN Index;
    Print(L"[HOOK_IMG] ImgArchStartBootApplicationHook called!\n");

    // check if winload

    BOOLEAN isWinload = CheckIfWinload(ImageBase, ImageSize);

    // DEBUG
    isWinload = TRUE; // force winload for testing

    // Print PE Signature

    if (isWinload) {
        Print(L"[HOOK_IMG] Detected winload.efi!\n");
        // winload_base = ImageBase;
    } else {
        Print(L"[HOOK_IMG] Not winload.efi, continuing...\n");
    }

    winload_base = ImageBase;
    Print(L"Inside ImgArchStartBootApplicationHook, press anything to continue...\n");
    uefi_call_wrapper(GlobalSystemTable->BootServices->WaitForEvent, 3, 1, &GlobalSystemTable->ConIn->WaitForKey, &Index);
    uefi_call_wrapper(GlobalSystemTable->ConIn->ReadKeyStroke, 2, GlobalSystemTable->ConIn, &Key);
    // ((VOID (*)(VOID *, VOID *))ImgArchStartBootApplicationCallGate)(AppEntry, ImageBase, ImageSize, BootOption, ReturnArguments, OriginalFunction, OriginalFunctionBytes);
    // EFI_STATUS status = ImgArchStartBootApplicationCallGate(
    //     AppEntry,
    //     ImageBase,
    //     ImageSize,
    //     BootOption,
    //     ReturnArguments
    // );
    // ((VOID (*)(VOID *, VOID *, UINT32, UINT32, PBL_RETURN_ARGUMENTS ))ImgArchStartBootApplicationCallGate)(AppEntry, ImageBase, ImageSize, BootOption, ReturnArguments);
    return ImgArchStartBootApplicationCallGate(AppEntry, ImageBase, ImageSize, BootOption, ReturnArguments);
    // return status;
    // return ImgArchStartBootApplicationCallGate(AppEntry, ImageBase, ImageSize, BootOption, ReturnArguments);
}


EFI_STATUS EFIAPI patchBootMgr(
	IN CONST VOID* ImageBase,
	IN UINTN ImageSize
	)
{
    PIMAGE_NT_HEADERS64 NtHeaders = RtlpImageNtHeaderEx(ImageBase, ImageSize);
    if (NtHeaders == NULL) {
        Print(L"[HOOK] Failed to get NT headers\n");
        return EFI_NOT_FOUND;
    }
    Print(L"[HOOK] NT Headers found at: 0x%lx\n", (UINTN)NtHeaders);
        
    UINT8* Found = NULL;
    CONST PIMAGE_SECTION_HEADER CodeSection = (PIMAGE_SECTION_HEADER)((UINT8*)NtHeaders + sizeof(UINT32)+ sizeof(IMAGE_FILE_HEADER) + NtHeaders->FileHeader.SizeOfOptionalHeader);

    if (CodeSection == NULL) {
        Print(L"[HOOK] Failed to get Code Section\n");
        return EFI_NOT_FOUND;
    }
    Print(L"[HOOK] Code Section found at: 0x%lx, Size: %lu\n", (UINTN)CodeSection->VirtualAddress, CodeSection->SizeOfRawData);



    EFI_STATUS Status = FindPattern(SigImgArchStartBootApplication, 0xCC, sizeof(SigImgArchStartBootApplication), ImageBase + CodeSection->VirtualAddress, (UINT32)CodeSection->SizeOfRawData, (VOID**)&Found);
    // EFI_STATUS Status = FindPattern(SigImgArchStartBootApplication, 0xCC, sizeof(SigImgArchStartBootApplication), ImageBase, (UINT32)ImageSize, (VOID**)&Found);
    if (EFI_ERROR(Status)) {
        Print(L"[HOOK] Failed to find ImgArchStartBootApplication signature (0x%lx)\n", Status);
        return Status;
    }
    Print(L"[HOOK] Found ImgArchStartBootApplication at: 0x%lx\n", (UINTN)Found);

    if (Found != NULL) {

        // Patch the ImgArchStartBootApplication function
        // DebugPEHeaders((VOID*)ImageBase);  

        VOID* FoundStart = FindFunctionStart(ImageBase, (PIMAGE_NT_HEADERS64)NtHeaders,Found);
        // Status = FindFunctionStart(SigImgArchFunctionStart, 0xCC, sizeof(SigImgArchFunctionStart), *Found, ImageSize, (VOID**)&FoundStart);

        if (FoundStart == NULL){
            Print(L"Peccato, no trovato function Start");
        }
        Print(L"[HOOK] Trovato ImgArchStartBootApplication Function Start a : 0x%lx\n", (UINTN)FoundStart);

        VOID* ImgArchStartBootApplicationAddr = FoundStart;

        // UINT32 ImgArchOffset = (UINT8*)Found - (UINT8*)FoundStart;
        UINT32 ImgArchOffset = sizeof(SigImgArchFunctionStart);
        Print(L"[HOOK] ImgArchStartBootApplicationAddr: 0x%lx, ImgArchOffset: 0x%x\n", (UINTN)ImgArchStartBootApplicationAddr, ImgArchOffset);

     
        
        
        __builtin_memcpy(original_img_arch_bytes,ImgArchStartBootApplicationAddr, 0x30);

        *((UINT16*)ImgArchStartBootApplicationAddr) = 0x25FF; // jmp far
        *((UINT32*)((UINT8*)ImgArchStartBootApplicationAddr + 2)) = 0x00; // segment selector (0x00 for kernel)
        *((UINT64*)((UINT8*)ImgArchStartBootApplicationAddr + 6)) = (UINT64)ImgArchStartBootApplicationHook; // address of the hook function

        __builtin_memcpy(ImgArchStartBootApplicationCallGate, original_img_arch_bytes, 0x30);

        *((UINT16*)((UINT8*)ImgArchStartBootApplicationCallGate + ImgArchOffset)) = 0x25FF; // jmp far
        *((UINT32*)((UINT8*)ImgArchStartBootApplicationCallGate + ImgArchOffset + 2)) = 0x00; // segment selector (0x00 for kernel)
        *((UINT64*)((UINT8*)ImgArchStartBootApplicationCallGate + ImgArchOffset + 6)) = (UINT64)(ImgArchStartBootApplicationAddr) + ImgArchOffset; // address of the original function

        Print(L"[HOOK] ImgArchStartBootApplication hooked successfully!\n");
        // Patch the ImgArchStartBootApplication function

    } else {
        Print(L"[HOOK] ImgArchStartBootApplication signature not found\n");
    }
    return EFI_SUCCESS;

}


// Hook function for ExitBootServices
EFI_STATUS __attribute__((ms_abi)) ExitBootServicesHook(IN EFI_HANDLE ImageHandle, IN UINTN MapKey) {
    EFI_STATUS Status;
    VOID *OslArchTransferToKernelAddr;
    VOID *ReturnAddr;
    VOID *OslFwpKernelSetupPhase1;


    // return uefi_call_wrapper(OriginalExitBootServices, 2, ImageHandle, MapKey);
    
    // Here you can add your custom logic before exiting boot services
    Print(L"[HOOK] ExitBootServices called!\n");
    Print(L"[HOOK] ImageHandle: 0x%lx, MapKey: 0x%lx\n", ImageHandle, MapKey);
    
    // Get return address
    ReturnAddr = GetReturnAddress();
    Print(L"[HOOK] Return address: 0x%lx\n", (UINTN)ReturnAddr);
    
    // Try to find OslArchTransferToKernel using the return address
    // Print(L"[HOOK] Searching for OslArchTransferToKernel...\n");
    OslArchTransferToKernelAddr = FindOslArchTransferToKernel(ReturnAddr);
    // __builtin_memcpy(OriginalOslArchTransferToKernelAddr, OslArchTransferToKernelAddr, 0x8);

    OriginalOslArchTransferToKernelAddr = OslArchTransferToKernelAddr;
    __builtin_memcpy(original_osl_transfer_bytes, OslArchTransferToKernelAddr, OslFunctionOffset);

    UINT8* Found = NULL;

    FindPattern(SigOslFwpKernelSetupPhase1, 0xCC, sizeof(SigOslFwpKernelSetupPhase1), (VOID*)winload_base, 0x100000, (VOID**)&Found);
    if (Found != NULL) {
        OslFwpKernelSetupPhase1 = Found;
        // Print(L"[HOOK] Found OslFwpKernelSetupPhase1 at: 0x%lx\n", (UINTN)OslFwpKernelSetupPhase1);
    } else {
        OslFwpKernelSetupPhase1 = NULL;
    }

    
    VOID* OslFwpKernelSetupPhase1Base = FindOslFwpKernelSetupPhase1Base(OslFwpKernelSetupPhase1);

    // if (OslFwpKernelSetupPhase1Base != NULL) {
    //     Print(L"[HOOK] OslFwpKernelSetupPhase1Base found at: 0x%lx\n", (UINTN)OslFwpKernelSetupPhase1Base);
    // } else {
    //     Print(L"[HOOK] OslFwpKernelSetupPhase1Base not found\n");
    // }

    UINT16 OslFwpOffset = (UINTN)OslFwpKernelSetupPhase1 - (UINTN)OslFwpKernelSetupPhase1Base;

    // Print(L"[HOOK] OslFwpKernelSetupPhase1 offset: 0x%x\n", OslFwpOffset);




    // if (OslArchTransferToKernelAddr != NULL) {
    //     Print(L"[HOOK] Found OslArchTransferToKernel at: 0x%lx\n", (UINTN)OslArchTransferToKernelAddr);
    //     // You can now hook this function or perform other actions
    // } else {
    //     Print(L"[HOOK] OslArchTransferToKernel not found\n");
    // }


    *(UINT16*)(OslFwpKernelSetupPhase1Base + 0x00) = (UINT16)0x25FF; // jmp far
    *(UINT32*)(OslFwpKernelSetupPhase1Base + 0x02) = (UINT32)0x00; // segment selector (0x00 for kernel)
    *(UINT64*)(OslFwpKernelSetupPhase1Base + 0x06) = (UINT64)OslFwpKernelSetupPhase1Hook; // address of the hook function

    // Print(L"[HOOK] OslFwpKernelSetupPhase1 hooked successfully!\n");

    UINT8 original_osl_fwp_bytes[0x100] = {0};
    __builtin_memcpy(original_osl_fwp_bytes, OslFwpKernelSetupPhase1, 0x100);

    *(UINT16*)(OslFwpKernelSetupPhase1CallGate + OslFwpOffset + 0x00) = (UINT16)0x25FF; // jmp far
    *(UINT32*)(OslFwpKernelSetupPhase1CallGate + OslFwpOffset + 0x02) = (UINT32)0x00; // segment selector (0x00 for kernel)
    *(UINT64*)(OslFwpKernelSetupPhase1CallGate + OslFwpOffset + 0x06) = (UINT64)(OslFwpKernelSetupPhase1Base) + OslFwpOffset; // address of the original function




    // hook the OslArchTransferToKernel function
    __builtin_memcpy(OslArchTransferToKernelCallGate, original_osl_transfer_bytes, OslFunctionOffset);

    *(UINT16*)(OslArchTransferToKernelAddr + 0x00) = (UINT16)0x25FF;
    *(UINT32*)(OslArchTransferToKernelAddr + 0x02) = (UINT32)0x00;
    *(UINT64*)(OslArchTransferToKernelAddr + 0x06) = (UINT64)OslArchTransferToKernelHook;
    //*(UINT64*)(OslArchTransferToKernelAddr + 0x06) = (UINT64)OslArchTransferToKernelCallGate;


    // Print(L"[HOOK] OslArchTransferToKernel hooked successfully!\n");

    // Print(L"[HOOK] OslArchTranferToKernel at : 0x%lx  Now\n", (UINTN)OslArchTransferToKernelAddr);
    // for (UINTN i = 0; i < 0x30; i++) {
    //     Print(L"%02x ", ((UINT8*)OslArchTransferToKernelAddr)[i]);
    // }

    *(UINT16*)(OslArchTransferToKernelCallGate + OslFunctionOffset + 0x00) = (UINT16)0x25FF;
    *(UINT32*)(OslArchTransferToKernelCallGate + OslFunctionOffset + 0x02) = (UINT32)0x00;
    *(UINT64*)(OslArchTransferToKernelCallGate + OslFunctionOffset + 0x06) = (UINT64)(OriginalOslArchTransferToKernelAddr) + OslFunctionOffset;

    // Print(L"[HOOK] OslArchTransferToKernelHook  at: 0x%lx\n", (UINTN)OslArchTransferToKernelHook);
    // Print(L"[HOOK] OslArchTransferToKernelCallGate at: 0x%lx  Now\n", (UINTN)OslArchTransferToKernelCallGate);
    // for (UINTN i = 0; i < 0x30; i++) {
    //     Print(L"%02x ", ((UINT8*)OslArchTransferToKernelCallGate)[i]);
    // }

    
    // Call the original ExitBootServices
    if (OriginalExitBootServices != NULL) {
        Print(L"[HOOK] Calling original ExitBootServices...\n");
        return uefi_call_wrapper(OriginalExitBootServices, 2, ImageHandle, MapKey);

        //return EFI_SUCCESS;
        Print(L"[HOOK] Original ExitBootServices returned: 0x%lx\n", Status);
    } else {
        Print(L"[HOOK] ERROR: Original ExitBootServices is NULL!\n");
        Status = EFI_UNSUPPORTED;
    }
    
    return Status;
}

EFI_STATUS __attribute__((ms_abi)) LoadImageHook(
    IN BOOLEAN BootPolicy,
    IN EFI_HANDLE ParentImageHandle,
    IN EFI_DEVICE_PATH_PROTOCOL *DevicePath,
    IN VOID *SourceBuffer OPTIONAL,
    IN UINTN SourceSize,
    OUT EFI_HANDLE *ImageHandle
) {
    EFI_STATUS Status;

    Print(L"[HOOK] LoadImage called!\n");
    // Print ALL Parameters
    Print(L"[HOOK] BootPolicy: %d\n", BootPolicy);
    Print(L"[HOOK] ParentImageHandle: 0x%lx\n", (UINTN)ParentImageHandle);
    Print(L"[HOOK] DevicePath: 0x%lx\n", (UINTN)DevicePath);
    Print(L"[HOOK] SourceBuffer: 0x%lx\n", (UINTN)SourceBuffer);
    Print(L"[HOOK] SourceSize: %lu\n", SourceSize);
    Print(L"[HOOK] ImageHandle: 0x%lx\n", (UINTN)ImageHandle);

    EFI_GUID MyShellProtocolGuid = EFI_SHELL_PROTOCOL_GUID;

    EFI_SHELL_PROTOCOL* EfiShellProtocol = NULL;
    Status = uefi_call_wrapper(GlobalSystemTable->BootServices->LocateProtocol, 3,
                               &MyShellProtocolGuid, NULL, (VOID**)&EfiShellProtocol);


    CHAR16* ImagePath = NULL;

    if (!EFI_ERROR(Status) && EfiShellProtocol != NULL) {
        // Get the full path of the image being loaded
        Status = uefi_call_wrapper(EfiShellProtocol->GetFilePathFromDevicePath, 2, DevicePath, &ImagePath);
        if (EFI_ERROR(Status)) {
            Print(L"[HOOK] Failed to get image path from device path (0x%lx)\n", Status);
            return Status;
        }
        Print(L"[HOOK] Image Path: %s\n", ImagePath);
    } else {
        Print(L"[HOOK] Shell Protocol not found or error occurred (0x%lx)\n", Status);
        Print(L"[HOOK] Trying to use DevicePath directly...\n");
    }

    if (ImagePath == NULL) {
        // ImagePath = ConvertDevicePathToText(DevicePath, TRUE, TRUE);

        if (DevicePath != NULL) {
            ImagePath = DevicePathToStr(DevicePath);
            if (ImagePath == NULL) {
                Print(L"[HOOK] Failed to convert DevicePath to string\n");
                return EFI_OUT_OF_RESOURCES;
            }
            Print(L"[HOOK] DevicePath as string: %s\n", ImagePath);
        } else {
            Print(L"[HOOK] DevicePath is NULL, cannot convert to string\n");
            return EFI_INVALID_PARAMETER;
        }
    }

    Status = uefi_call_wrapper(
    OriginalLoadImage, 6, BootPolicy, ParentImageHandle, DevicePath, SourceBuffer, SourceSize, ImageHandle);
    if (EFI_ERROR(Status)) {
        Print(L"[HOOK] Original LoadImage failed (0x%lx)\n", Status);
        return Status;
    }

    if (StriStr(ImagePath, L"bootmgfw-orig") != NULL) {
        Print(L"[HOOK] Detected bootmgfw-orig.efi, skipping hook...\n");
        // return EFI_SUCCESS; // Skip hooking if it's the original bootmgfw
        


        EFI_LOADED_IMAGE_PROTOCOL *LoadedImage = NULL;
        // 
        // Status = uefi_call_wrapper(GlobalSystemTable->BootServices->HandleProtocol, 3,
        //                            ParentImageHandle, &gEfiLoadedImageProtocolGuid, (VOID**)&LoadedImage);

        CONST EFI_STATUS ImageInfoStatus = uefi_call_wrapper(GlobalSystemTable->BootServices->OpenProtocol, 4,
            *ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID**)&LoadedImage, ImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
        if (EFI_ERROR(ImageInfoStatus)) {
            Print(L"[HOOK] Failed to get LoadedImage protocol (0x%lx)\n", Status);
        
        }
        if (LoadedImage != NULL) {
            Print(L"[HOOK] LoadedImage Protocol found, ImageBase: 0x%lx\n", (UINTN)LoadedImage->ImageBase);
            // Print(L"[HOOK] LoadedImage Size: %lu\n", LoadedImage->ImageSize);
            BootmgfwBase = LoadedImage->ImageBase;
            BootmgfwSize = LoadedImage->ImageSize;


            Print(L"[HOOK] Original LoadImage called successfully, now patching BootMgr...\n");

            patchBootMgr(LoadedImage->ImageBase, LoadedImage->ImageSize);
        } else {
            Print(L"[HOOK] LoadedImage Protocol is NULL, cannot get ImageBase\n");
            return EFI_NOT_FOUND;
        }
    }
    return Status;

    // // Call the original LoadImage if it exists
    // if (OriginalLoadImage != NULL) {
    //     Print(L"[HOOK] Calling original LoadImage...\n");
    //     // Status = uefi_call_wrapper(OriginalLoadImage, 6, BootPolicy, ParentImageHandle, DevicePath, SourceBuffer, SourceSize, ImageHandle);
    //     // Print(L"[HOOK] Original LoadImage returned: 0x%lx\n", Status);
    //     return uefi_call_wrapper(
    //         OriginalLoadImage, 6, BootPolicy, ParentImageHandle, DevicePath, SourceBuffer, SourceSize, ImageHandle
    //     );
    // } else {
    //     Print(L"[HOOK] ERROR: Original LoadImage is NULL!\n");
    //     return EFI_UNSUPPORTED;
    // }
}




// EFI_STATUS EFIAPI winload_base(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE *SystemTable) {
//     // i should iterate memory to find winload.efi base address


//     return EFI_SUCCESS;
// }

// put a label for goto
EFI_STATUS EFIAPI efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS Status;
    EFI_INPUT_KEY Key;
    UINTN Index;
    
    // Initialize the library
    InitializeLib(ImageHandle, SystemTable);
    
    // Save system table globally
    GlobalSystemTable = SystemTable;
    
    // Clear screen
    uefi_call_wrapper(SystemTable->ConOut->ClearScreen, 1, SystemTable->ConOut);
    
    // Print Hello World
    Print(L"Hello World from UEFI!\n");
    
    // Optional: Wait for a keypress (comment out for automatic boot)
    Print(L"Press any key to continue boot...\n");
    uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3, 1, &SystemTable->ConIn->WaitForKey, &Index);
    uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2, SystemTable->ConIn, &Key);

    // Hook ExitBootServices
    Print(L"Installing ExitBootServices hook...\n");
    
    OriginalLoadImage = SystemTable->BootServices->LoadImage;

    SystemTable->BootServices->LoadImage = LoadImageHook;
    Print(L"LoadImage hook installed at: 0x%lx\n", (UINTN)LoadImageHook);

    // Save the original ExitBootServices pointer
    OriginalExitBootServices = SystemTable->BootServices->ExitBootServices;
    Print(L"Original ExitBootServices at: 0x%lx\n", (UINTN)OriginalExitBootServices);

    // Replace with our hook
    SystemTable->BootServices->ExitBootServices = ExitBootServicesHook;
    Print(L"Hook installed at: 0x%lx\n", (UINTN)ExitBootServicesHook);
    
    // recalculate crc32
    Print(L"Calculating CRC32 for ExitBootServices hook...\n");
    SystemTable->BootServices->Hdr.CRC32 = 0;
    uefi_call_wrapper(SystemTable->BootServices->CalculateCrc32, 3,
                    SystemTable->BootServices,
                    SystemTable->BootServices->Hdr.HeaderSize,
                    &SystemTable->BootServices->Hdr.CRC32);

    Print(L"CRC32 for ExitBootServices hook: 0x%08x\n", SystemTable->BootServices->Hdr.CRC32);
    // SystemTable->BootServices->Hdr

    // Try to load the next stage bootloader
    // First try bootmgfw.efi (Windows Boot Manager)
    Print(L"Attempting to load Bootmgfw...\n");

    Status = SetVbsPolicyDisable(SystemTable);
    if (EFI_ERROR(Status)) {
        Print(L"[VBS] Failed to set VbsPolicyDisable, continuing anyway...\n");
    } else {
        Print(L"[VBS] VbsPolicyDisable set successfully.\n");
    }
    Status = LoadAndExecuteImage(ImageHandle, SystemTable, L"\\EFI\\Microsoft\\Boot\\bootmgfw-orig.efi");

    if (EFI_ERROR(Status)) {
        Print(L"ERROR: Failed to load bootmgfw.efi (0x%lx),\n", Status);

    }
    
    // If we reach this point, we failed to load any bootloader
    if (EFI_ERROR(Status)) {
        Print(L"Failed to load any bootloader. System halted.\n");
        Print(L"Press any key to shutdown...\n");
        uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3, 1, &SystemTable->ConIn->WaitForKey, &Index);
        uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2, SystemTable->ConIn, &Key);
        
        // Restore original ExitBootServices before returning
        if (OriginalExitBootServices != NULL) {
            SystemTable->BootServices->ExitBootServices = OriginalExitBootServices;
        }
    }
    
    return Status;
}