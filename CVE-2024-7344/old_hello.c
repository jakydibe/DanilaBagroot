#include <efi.h>
#include <efilib.h>

// BCD store namespace GUID
#define BCD_GUID \
    { 0x9dea862c, 0x5cdd, 0x4e70, { 0xac, 0xc1, 0xf3, 0x2b, 0x34, 0x4d, 0x47, 0x95 } }

// Function to set BCD AllowPrereleaseSignatures variable
EFI_STATUS SetBCDAllowPrereleaseSignatures(EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS Status;
    EFI_GUID BcdGuid = BCD_GUID;
    UINT32 Attributes;
    UINT32 Value = 1;  // Set to 1 to allow prerelease signatures
    
    Print(L"Setting BCD AllowPrereleaseSignatures...\n");
    
    // Set attributes for BCD variables
    Attributes = EFI_VARIABLE_NON_VOLATILE | 
                 EFI_VARIABLE_BOOTSERVICE_ACCESS | 
                 EFI_VARIABLE_RUNTIME_ACCESS;
    
    // Set the AllowPrereleaseSignatures variable
    Status = uefi_call_wrapper(SystemTable->RuntimeServices->SetVariable, 5,
                               L"AllowPrereleaseSignatures",
                               &BcdGuid,
                               Attributes,
                               sizeof(UINT32),
                               &Value);
    
    if (EFI_ERROR(Status)) {
        Print(L"ERROR: Failed to set AllowPrereleaseSignatures: %r\n", Status);
        return Status;
    }
    
    Print(L"Successfully set AllowPrereleaseSignatures to %d\n", Value);
    return EFI_SUCCESS;
}

// Function to load and execute the next bootloader
EFI_STATUS LoadAndExecuteImage(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable, CHAR16 *FileName) {
    EFI_STATUS Status;
    EFI_LOADED_IMAGE_PROTOCOL *LoadedImage;
    EFI_DEVICE_PATH_PROTOCOL *DevicePath;
    EFI_HANDLE NextImageHandle;
    
    // Get the loaded image protocol for the current image
    Status = uefi_call_wrapper(SystemTable->BootServices->HandleProtocol, 3,
                               ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID **)&LoadedImage);
    if (EFI_ERROR(Status)) {
        return Status;
    }
    
    // Create device path for the next bootloader
    DevicePath = FileDevicePath(LoadedImage->DeviceHandle, FileName);
    if (!DevicePath) {
        return EFI_OUT_OF_RESOURCES;
    }
    
    // Load the next bootloader image
    Status = uefi_call_wrapper(SystemTable->BootServices->LoadImage, 6,
                               FALSE, ImageHandle, DevicePath, NULL, 0, &NextImageHandle);
    if (EFI_ERROR(Status)) {
        return Status;
    }
    
    // Start the next bootloader
    Status = uefi_call_wrapper(SystemTable->BootServices->StartImage, 3,
                               NextImageHandle, NULL, NULL);
    
    return Status;
}
EFI_STATUS EFIAPI efi_main(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS Status;
    EFI_INPUT_KEY Key;
    UINTN Index;
    
    // Initialize the library
    InitializeLib(ImageHandle, SystemTable);
    
    // Clear screen
    uefi_call_wrapper(SystemTable->ConOut->ClearScreen, 1, SystemTable->ConOut);
    
    // Print Hello World
    Print(L"Hello World from UEFI!\n");
    Print(L"Custom bootloader with BCD modification support\n\n");
    
    // Set BCD AllowPrereleaseSignatures variable
    Status = SetBCDAllowPrereleaseSignatures(SystemTable);
    if (EFI_ERROR(Status)) {
        Print(L"WARNING: Could not set BCD variable, continuing anyway...\n");
    }
    
    Print(L"Press any key to continue boot...\n");
    uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3, 1, &SystemTable->ConIn->WaitForKey, &Index);
    uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2, SystemTable->ConIn, &Key);

    // Try to load the next stage bootloader
    // First try bootmgfw.efi (Windows Boot Manager)
    Print(L"Attempting to load Windows Boot Manager...\n");
    Status = LoadAndExecuteImage(ImageHandle, SystemTable, L"\\EFI\\Microsoft\\Boot\\bootmgfw-orig.efi");
    
    if (EFI_ERROR(Status)) {
        Print(L"ERROR: Failed to load bootmgfw.efi, maybe Windows is not present, trying grub on Ubuntu...\n");
        Status = LoadAndExecuteImage(ImageHandle, SystemTable, L"\\EFI\\ubuntu\\grubx64.efi");
        
        if (EFI_ERROR(Status)) {
            Print(L"ERROR: Failed to load grubx64.efi\n");
            Print(L"Press any key to return to firmware...\n");
            uefi_call_wrapper(SystemTable->BootServices->WaitForEvent, 3,
                              1,
                              &SystemTable->ConIn->WaitForKey,
                              &Index);
            uefi_call_wrapper(SystemTable->ConIn->ReadKeyStroke, 2,
                              SystemTable->ConIn,
                              &Key);
        }
    }
    
    // This point should not be reached if the next bootloader starts successfully
    return Status;
}
