#include <efi.h>
#include <efilib.h>
#include <stddef.h>        
#include "arch.h"
#include "pe.h"

PIMAGE_NT_HEADERS64
EFIAPI
RtlpImageNtHeaderEx(
    IN CONST VOID* Base,
    IN UINTN Size OPTIONAL
    );

#define MAX_UINT32  0xFFFFFFFF



extern VOID  *winload_base;      // just a declaration â€“ no storage here
extern UINTN  OslFunctionOffset; // or extern VOID *OslFunctionAddress;
extern UINT8 original_osl_transfer_bytes[0x30]; // buffer to store original bytes of OslArchTransferToKernel


STATIC CONST UINT8 SigImgArchStartBootApplication[] = {
	0x41, 0xB8, 0x09, 0x00, 0x00, 0xD0				// mov r8d, 0D0000009h
};

STATIC CONST UINT8 SigImgArchFunctionStart[] = {
    0x48, 0x8B, 0xC4,								// mov rax, rsp
    0x48, 0x89, 0x48, 0x08,							// mov [rax+8], rcx
    0x48, 0x89, 0x50, 0x10,							// mov [rax+10h], rdx
    0x4C, 0x89, 0x40, 0x18,							// mov [rax+18h], r8
    0x4C, 0x89, 0x48, 0x20							// mov [rax+20h], r9
};

STATIC CONST UINT8 SigBlStatusPrint[] = {
	0x48, 0x8B, 0xC4,								// mov rax, rsp
	0x48, 0x89, 0x48, 0x08,							// mov [rax+8], rcx
	0x48, 0x89, 0x50, 0x10,							// mov [rax+10h], rdx
	0x4C, 0x89, 0x40, 0x18,							// mov [rax+18h], r8
	0x4C, 0x89, 0x48, 0x20,							// mov [rax+20h], r9
	0x53,											// push rbx
	0x48, 0x83, 0xEC, 0x40,							// sub rsp, 40h
	0xE8, 0xCC, 0xCC, 0xCC, 0xCC,					// call BlBdDebuggerEnabled
	0x84, 0xC0,										// test al, al
	0x74, 0xCC										// jz XX
};


#define EFI_SHELL_PROTOCOL_GUID \
  { 0x6302d008, 0x7f9b, 0x4f30, { 0x87, 0xac, 0x60, 0xc9, 0xfe, 0xf5, 0xda, 0x4e } }

#define EFI_VBS_POLICY_GUID \
    {0x77fa9abd, 0x0359, 0x4d32, { 0xbd, 0x60, 0x28, 0xf4, 0xe7, 0x8f, 0x78, 0x4b }}



CHAR16 CharToUpper(CHAR16 c) {
    if (c >= L'a' && c <= L'z') {
        return c - (L'a' - L'A');
    }
    return c;
}

CONST CHAR16*
EFIAPI
StriStr(
	IN CONST CHAR16 *String1,
	IN CONST CHAR16 *String2
	)
{
	if (*String2 == L'\0')
		return String1;

	while (*String1 != L'\0')
	{
		CONST CHAR16* FirstMatch = String1;
		CONST CHAR16* String2Ptr = String2;
		CHAR16 String1Char = CharToUpper(*String1);
		CHAR16 String2Char = CharToUpper(*String2Ptr);

		while (String1Char == String2Char && String1Char != L'\0')
		{
			String1++;
			String2Ptr++;

			String1Char = CharToUpper(*String1);
			String2Char = CharToUpper(*String2Ptr);
		}

		if (String2Char == L'\0')
			return FirstMatch;

		if (String1Char == L'\0')
			return NULL;

		String1 = FirstMatch + 1;
	}
	return NULL;
}

BOOLEAN CompareUnicodeString(UNICODE_STRING* str1, CHAR16* str2) {
    UINT16 len = StrLen(str2);
    if (str1->Length / sizeof(CHAR16) != len) {
        return FALSE;
    }
    
    for (UINTN i = 0; i < len; i++) {
        if (str1->Buffer[i] != str2[i]) {
            return FALSE;
        }
    }
    return TRUE;
}



UINT8 COMPAREDASTRING(CONST CHAR16* String1, CONST CHAR16* String2, UINTN Length)
{
    if (String1 == NULL || String2 == NULL || Length == 0)
        return 0;

    while (Length-- > 0 && *String1 && *String2)
    {
        if (CharToUpper(*String1) != CharToUpper(*String2))
            return CharToUpper(*String1) - CharToUpper(*String2);
        String1++;
        String2++;
    }

    return Length == 0 ? 0 : (*String1 ? 1 : -1);
}

// PKLDR_DATA_TABLE_ENTRY GetLoadedModule( LIST_ENTRY* LoadOrderListHead, CHAR16* ModuleName )
// {
// 	if (ModuleName == NULL || LoadOrderListHead == NULL)
// 		return NULL;

//     // int max_iterations = 1000; // Limit iterations to prevent infinite loop

// 	LIST_ENTRY* ListEntry = LoadOrderListHead;
//     while(ListEntry->Flink != LoadOrderListHead) // Iterate through the list{
// 	{
// 		PKLDR_DATA_TABLE_ENTRY Entry = CONTAINING_RECORD( ListEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks );
// 		if (Entry && (StrnCmp( Entry->BaseImageName.Buffer, ModuleName, 4 ) == 0))
// 			return Entry;
//         // if (--max_iterations <= 0) {
//         //     // Print(L"[ERROR] Exceeded maximum iterations while searching for module: %s\n", ModuleName);
//         //     return 1; // Prevent infinite loop
//         // }
//         ListEntry = ListEntry->Flink; // Move to the next entry
// 	}
//     return 1;
// 	// return NULL;
// }



INTN
EFIAPI
StrniCmp(
	IN CONST CHAR16 *FirstString,
	IN CONST CHAR16 *SecondString,
	IN UINTN Length
	)
{
	if (FirstString == NULL || SecondString == NULL || Length == 0)
		return 0;

	CHAR16 UpperFirstChar = CharToUpper(*FirstString);
	CHAR16 UpperSecondChar = CharToUpper(*SecondString);
	while ((*FirstString != L'\0') && (*SecondString != L'\0') &&
		(UpperFirstChar == UpperSecondChar) &&
		(Length > 1))
	{
		FirstString++;
		SecondString++;
		UpperFirstChar = CharToUpper(*FirstString);
		UpperSecondChar = CharToUpper(*SecondString);
		Length--;
	}

	return UpperFirstChar - UpperSecondChar;
}

UINT8*
EFIAPI
FindOslFwpKernelSetupPhase1Base(
	IN CONST UINT8* AddressInFunction
	)
{
    UINT8 sigArr[] = { 0x48, 0x89, 0x4C, 0x24, 0x08, 0x55, 0x53, 0x56, 0x57, 0x41, 0x54,0x41};


    UINT8 pattern_length = sizeof(sigArr) / sizeof(sigArr[0]);

    UINT8 *Current = (UINT8*)((UINTN)AddressInFunction); // Align to page boundary

    for(int i = 0; i < 0x1000; i += 1) {
        UINT8 *Ptr = Current - i;
        for (int j = 0; j < pattern_length; j++) {
            if (Ptr[j] != sigArr[j]) {
                break;
            }
            if (j == pattern_length - 1) {
                return Ptr;
            }
        }
    }

    return NULL;

}





// STATIC
// PKLDR_DATA_TABLE_ENTRY
// EFIAPI
// GetBootLoadedModule(
// 	IN CONST LIST_ENTRY* LoadOrderListHead,
// 	IN CONST CHAR16* ModuleName
// 	)
// {
// 	if (ModuleName == NULL || LoadOrderListHead == NULL)
// 		return NULL;

// 	for (LIST_ENTRY* ListEntry = LoadOrderListHead->Flink; ListEntry != LoadOrderListHead; ListEntry = ListEntry->Flink)
// 	{
// 		// This is fairly heavy abuse of CR(), but legal C because (only) the first field of a struct is guaranteed to be at offset 0 (C99 6.7.2.1, point 13)
// 		CONST PBLDR_DATA_TABLE_ENTRY Entry = (PBLDR_DATA_TABLE_ENTRY)BASE_CR(ListEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
// 		if (Entry != NULL && StrniCmp(Entry->KldrEntry.BaseDllName.Buffer, ModuleName, (Entry->KldrEntry.BaseDllName.Length / sizeof(CHAR16))) == 0)
// 			return &Entry->KldrEntry;
// 	}
// 	return NULL;
// }


// Function to set VbsPolicyDisable NVRAM variable, thx claude
EFI_STATUS SetVbsPolicyDisable(EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS Status;
    EFI_GUID VbsPolicyGuid = EFI_VBS_POLICY_GUID;
    UINT8 VbsPolicyValue = 1;  // 1 = Disable VBS, 0 = Enable VBS
    
    Print(L"[VBS] Setting VbsPolicyDisable NVRAM variable...\n");
    
    // Set the VbsPolicyDisable variable
    // Attributes: EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS
    Status = uefi_call_wrapper(
        SystemTable->RuntimeServices->SetVariable, 
        5,
        L"VbsPolicyDisable",        // Variable name
        &VbsPolicyGuid,             // GUID
        EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
        sizeof(UINT8),              // Data size
        &VbsPolicyValue             // Data
    );
    
    if (EFI_ERROR(Status)) {
        Print(L"[VBS] ERROR: Failed to set VbsPolicyDisable variable (0x%lx)\n", Status);
        if (Status == EFI_SECURITY_VIOLATION) {
            Print(L"[VBS] Security violation - Secure Boot may be preventing variable modification\n");
        } else if (Status == EFI_OUT_OF_RESOURCES) {
            Print(L"[VBS] Out of resources - NVRAM may be full\n");
        }
    } else {
        Print(L"[VBS] Successfully set VbsPolicyDisable = %d\n", VbsPolicyValue);
        
        // Verify the variable was set correctly
        UINT8 ReadValue = 0;
        UINTN DataSize = sizeof(UINT8);
        Status = uefi_call_wrapper(
            SystemTable->RuntimeServices->GetVariable,
            5,
            L"VbsPolicyDisable",
            &VbsPolicyGuid,
            NULL,
            &DataSize,
            &ReadValue
        );
        
        if (!EFI_ERROR(Status)) {
            Print(L"[VBS] Verification: VbsPolicyDisable = %d\n", ReadValue);
        }
    }
    
    return Status;
}

// Function to load and execute the next bootloader
EFI_STATUS LoadAndExecuteImage(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable, CHAR16 *FileName) {
    EFI_STATUS Status;
    EFI_LOADED_IMAGE_PROTOCOL *LoadedImage;
    EFI_DEVICE_PATH_PROTOCOL *DevicePath;
    EFI_HANDLE NextImageHandle;
    
    // Get the loaded image protocol for the current image
    Status = uefi_call_wrapper(SystemTable->BootServices->HandleProtocol, 3,
                               ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID **)&LoadedImage);
    if (EFI_ERROR(Status)) {
        return Status;
    }
    
    // Create device path for the next bootloader
    DevicePath = FileDevicePath(LoadedImage->DeviceHandle, FileName);
    if (!DevicePath) {
        return EFI_OUT_OF_RESOURCES;
    }
    
    // Load the next bootloader image
    Status = uefi_call_wrapper(SystemTable->BootServices->LoadImage, 6,
                               FALSE, ImageHandle, DevicePath, NULL, 0, &NextImageHandle);
    if (EFI_ERROR(Status)) {
        Print(L"[Loading Image] ERROR: Failed to load image %s (0x%lx)\n", FileName, Status);
        return Status;
    }
    
    // Start the next bootloader
    Status = uefi_call_wrapper(SystemTable->BootServices->StartImage, 3,
                               NextImageHandle, NULL, NULL);
    
    return Status;
}

// just depth1 return address (used for getting winload.efi base)
VOID* GetReturnAddress() {
    return __builtin_extract_return_addr( __builtin_return_address( 1 ) );
}



// EFI_STATUS
// EFIAPI
// FindFunctionStart(
// 	IN CONST UINT8* Pattern,
// 	IN UINT8 Wildcard,
// 	IN UINT32 PatternLength,
// 	IN CONST VOID* Base,
// 	IN UINT32 Size,
// 	OUT VOID **Found
// 	)
// {
// 	if (Found == NULL || Pattern == NULL || Base == NULL)
// 		return EFI_INVALID_PARAMETER;

// 	*Found = NULL;
//     UINT8* Address = (UINT8*)Base;
// 	while(1){
// 		UINT32 i;
// 		for (i = 0; i < PatternLength; ++i)
// 		{
// 			if (Pattern[i] != Wildcard && (*(Address + i) != Pattern[i]))
// 				break;
// 		}

// 		if (i == PatternLength)
// 		{
// 			*Found = (VOID*)Address;
// 			return EFI_SUCCESS;
// 		}
//         Address -= 1; // Move backwards by one byte
// 	}

// 	return EFI_NOT_FOUND;
// }


// Debug function to examine the PE headers
void DebugPEHeaders(VOID* ImageBase) {
    PIMAGE_DOS_HEADER DosHeader = (PIMAGE_DOS_HEADER)ImageBase;
    Print(L"[HOOK] DOS Header at: %p\n", DosHeader);
    Print(L"[HOOK] e_magic: 0x%x (should be 0x5A4D)\n", DosHeader->e_magic);
    Print(L"[HOOK] e_lfanew: 0x%x\n", DosHeader->e_lfanew);
    
    PIMAGE_NT_HEADERS NtHeaders = (PIMAGE_NT_HEADERS)((UINT8*)ImageBase + DosHeader->e_lfanew);
    Print(L"[HOOK] NT Headers at: %p\n", NtHeaders);
    Print(L"[HOOK] Signature: 0x%x (should be 0x4550)\n", NtHeaders->Signature);
    
    // Check if it's 64-bit
    if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
        PIMAGE_NT_HEADERS64 NtHeaders64 = (PIMAGE_NT_HEADERS64)NtHeaders;
        Print(L"[HOOK] 64-bit image detected\n");
        Print(L"[HOOK] OptionalHeader at: %p\n", &NtHeaders64->OptionalHeader);
        Print(L"[HOOK] DataDirectory at: %p\n", &NtHeaders64->OptionalHeader.DataDirectory);
        Print(L"[HOOK] NumberOfRvaAndSizes: %d\n", NtHeaders64->OptionalHeader.NumberOfRvaAndSizes);
        
        // Print the offset of DataDirectory from OptionalHeader
        UINT32 DataDirOffset = (UINT8*)&NtHeaders64->OptionalHeader.DataDirectory - (UINT8*)&NtHeaders64->OptionalHeader;
        Print(L"[HOOK] DataDirectory offset from OptionalHeader: 0x%x (should be 0x70 for 64-bit)\n", DataDirOffset);
        
        // Manually read the first few data directories
        for (int i = 0; i < 5; i++) {
            PIMAGE_DATA_DIRECTORY Dir = &NtHeaders64->OptionalHeader.DataDirectory[i];
            Print(L"[HOOK] DataDir[%d] at %p: RVA=0x%x, Size=0x%x\n", 
                  i, Dir, Dir->VirtualAddress, Dir->Size);
        }
        
        // Also dump raw bytes at the DataDirectory location
        UINT8* RawData = (UINT8*)&NtHeaders64->OptionalHeader.DataDirectory;
        Print(L"[HOOK] Raw bytes at DataDirectory:\n");
        for (int i = 0; i < 32; i += 8) {
            Print(L"  +0x%02x: %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  i, RawData[i], RawData[i+1], RawData[i+2], RawData[i+3],
                  RawData[i+4], RawData[i+5], RawData[i+6], RawData[i+7]);
        }
    }
}


UINT8*
EFIAPI
FindFunctionStart(
    IN CONST UINT8* ImageBase,
    IN PIMAGE_NT_HEADERS64 NtHeaders,
    IN CONST UINT8* AddressInFunction
    )
{
    // Test for null. This allows callers to do 'FindPattern(..., &Address); X = Backtrack(Address, ...)' with a single failure branch
    if (AddressInFunction == NULL)
        return NULL;
    
    if (NtHeaders->OptionalHeader.NumberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_EXCEPTION)
        return NULL;
    Print(L"[HOOK] NtHeaders->OptionalHeader.NumberOfRvaAndSizes: %d\n", NtHeaders->OptionalHeader.NumberOfRvaAndSizes);
    // FINO A QUI A POSTO

    CONST PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionTable = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(ImageBase + 
        NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].VirtualAddress);
    CONST UINT32 FunctionTableSize = NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION].Size;

    // print all the Data Directory entries
    for (UINT32 i = 0; i < NtHeaders->OptionalHeader.NumberOfRvaAndSizes; i++) {
        Print(L"[HOOK] Data Directory[%d]: VirtualAddress: 0x%x, Size: %d\n", i,
            NtHeaders->OptionalHeader.DataDirectory[i].VirtualAddress,
            NtHeaders->OptionalHeader.DataDirectory[i].Size);
    }

    Print(L"[HOOK] FunctionTable: 0x%lx, FunctionTableSize: %d\n", (UINTN)FunctionTable, FunctionTableSize);
    
    if (FunctionTableSize == 0)
        return NULL;

    Print(L"[HOOK] FunctionTableSize: %d\n", FunctionTableSize);

    // Do a binary search until we find the function that contains our address
    CONST UINT32 RelativeAddress = (UINT32)(AddressInFunction - ImageBase);

    Print(L"[HOOK] RelativeAddress: 0x%x\n", RelativeAddress);
    PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry = NULL;
    INT32 Low = 0;
    INT32 High = (INT32)(FunctionTableSize / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) - 1;
    
    while (High >= Low)
    {
        CONST INT32 Middle = (Low + High) >> 1;
        FunctionEntry = &FunctionTable[Middle];

        if (RelativeAddress < FunctionEntry->BeginAddress)
            High = Middle - 1;
        else if (RelativeAddress >= FunctionEntry->EndAddress)
            Low = Middle + 1;
        else
            break;
    }
    Print(L"[HOOK] FunctionEntry found: BeginAddress: 0x%x, EndAddress: 0x%x\n", FunctionEntry->BeginAddress, FunctionEntry->EndAddress);

    if (High >= Low)
    {
        // If the function entry specifies indirection, get the address of its master function entry
        while ((FunctionEntry->u.UnwindData & RUNTIME_FUNCTION_INDIRECT) != 0)
        {
            FunctionEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)(FunctionEntry->u.UnwindData + ImageBase - 1);
        }

        // Traverse any chained unwind info until we find the primary function entry.
        PIMAGE_FUNCTION_UNWIND_INFO UnwindInfo = (PIMAGE_FUNCTION_UNWIND_INFO)(FunctionEntry->u.UnwindData + ImageBase);
        UINT32 ChainCount = 0;
        while ((UnwindInfo->Flags & UNW_FLAG_CHAININFO) != 0)
        {
            ChainCount += 1;
            if (ChainCount > UNWIND_CHAIN_LIMIT)
                return NULL;

            FunctionEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)&(UnwindInfo->UnwindCode[(UnwindInfo->CountOfUnwindCodes + 1) & ~1]);
            UnwindInfo = (PIMAGE_FUNCTION_UNWIND_INFO)(FunctionEntry->u.UnwindData + ImageBase);
        }
        
        return (UINT8*)ImageBase + FunctionEntry->BeginAddress;
    }

    return NULL;
}



EFI_STATUS
EFIAPI
FindPattern(
	IN CONST UINT8* Pattern,
	IN UINT8 Wildcard,
	IN UINT32 PatternLength,
	IN CONST VOID* Base,
	IN UINT32 Size,
	OUT VOID **Found
	)
{
	if (Found == NULL || Pattern == NULL || Base == NULL)
		return EFI_INVALID_PARAMETER;

	*Found = NULL;

	for (UINT8 *Address = (UINT8*)Base; Address < (UINT8*)((UINTN)Base + Size - PatternLength); ++Address)
	{
		UINT32 i;
		for (i = 0; i < PatternLength; ++i)
		{
			if (Pattern[i] != Wildcard && (*(Address + i) != Pattern[i]))
				break;
		}

		if (i == PatternLength)
		{
			*Found = (VOID*)Address;
			return EFI_SUCCESS;
		}
	}

	return EFI_NOT_FOUND;
}



// Function to find PE header by walking backwards from an address
UINT8* FindImageBaseFromAddress(VOID *Address) {
    UINT8 *Current = (UINT8*)((UINTN)Address & ~0xFFF); // Align to page boundary
    UINT32 *DosHeader;
    // PE_COFF_HEADER *PeHeader;
    
    // Print(L"[HOOK] Searching for PE header starting from 0x%lx\n", (UINTN)Current);
    
    // Walk backwards page by page (4KB at a time)
    while ((UINTN)Current > 0x1000) {
        // Check for DOS header "MZ" signature
        DosHeader = (UINT32*)Current;
        if (DosHeader[0] == 0x00905A4D) { // "MZ" signature
            // Verify PE header
            UINT32 PeOffset = *(UINT32*)(Current + 0x3C);
            if (PeOffset < 0x1000) { // Sanity check
                // Check PE signature
                if (*(UINT32*)(Current + PeOffset) == 0x00004550) { // "PE\0\0"
                    // Print(L"[HOOK] Found PE header at 0x%lx\n", (UINTN)Current);
                    return Current;
                }
            }
        }
        Current -= 0x1000; // Move back one page
    }
    
    // Print(L"[HOOK] PE header not found\n");
    return NULL;
}


PIMAGE_NT_HEADERS64
EFIAPI
RtlpImageNtHeaderEx(
    IN CONST VOID* Base,
    IN UINTN Size
    )
{
    CONST BOOLEAN RangeCheck = Size > 0;
    Print(L"[HOOK] RtlpImageNtHeaderEx called with Base: %lu, Size: %lu\n", Base, Size);
    // Check if we have at least a DOS header
    if (RangeCheck && Size < sizeof(IMAGE_DOS_HEADER))
        return NULL;
    
    // Verify DOS signature
    Print(L"[HOOK] Checking DOS Header at: %lu\n", Base);
    Print(L"[HOOK] e_magic: 0x%lu (should be 0x5A4D)\n", ((PIMAGE_DOS_HEADER)Base)->e_magic);
    if (((PIMAGE_DOS_HEADER)Base)->e_magic != IMAGE_DOS_SIGNATURE)
        return NULL;
    Print(L"[HOOK] DOS Header found at: %p\n", Base);
    // Get the offset to NT headers
    CONST INT32 e_lfanew = ((PIMAGE_DOS_HEADER)Base)->e_lfanew;
    
    // Validate the offset
    if (RangeCheck &&
        (e_lfanew >= Size ||
        e_lfanew < 0 ||  // Check for negative offset
        e_lfanew >= (MAX_UINT32 - sizeof(UINT32) - sizeof(IMAGE_FILE_HEADER)) ||
        e_lfanew + sizeof(UINT32) + sizeof(IMAGE_FILE_HEADER) >= Size))
    {
        return NULL;
    }
    Print(L"[HOOK] e_lfanew: %d\n", e_lfanew);
    
    // Calculate NT headers location
    CONST PIMAGE_NT_HEADERS64 NtHeaders = (PIMAGE_NT_HEADERS64)(((UINT8*)Base) + e_lfanew);
    
    // On x64, verify this is a canonical address
    #ifdef _WIN64
    if (!RtlIsCanonicalAddress((UINTN)NtHeaders))
        return NULL;
    #endif
    Print(L"[HOOK] NT Headers found at: %p\n", NtHeaders);
    
    // Verify NT signature
    if (NtHeaders->Signature != IMAGE_NT_SIGNATURE)
        return NULL;
        
    return NtHeaders;
}


// Function to find OslArchTransferToKernel in the loaded image
VOID* FindOslArchTransferToKernel(VOID *ReturnAddress) {
    UINT8 *ImageBase;
    UINT32 *DosHeader;
    IMAGE_FILE_HEADER *PeHeader;
    IMAGE_OPTIONAL_HEADER64 *OptHeader;
    IMAGE_SECTION_HEADER *SectionHeader;
    UINTN i, j;
    UINT8 *Ptr;
    VOID *OslFunctionAddr = NULL;
    
    // Find image base from return address
    ImageBase = FindImageBaseFromAddress(ReturnAddress);
    if (ImageBase == NULL) {
        Print(L"[HOOK] Failed to find image base from return address\n");
        return NULL;
    }

    winload_base = ImageBase;
    Print(L"[HOOK] winload_base: 0x%lx\n", (UINTN)winload_base);
    
    Print(L"[HOOK] Image Base found at: 0x%lx\n", (UINTN)ImageBase);
    
    // Check DOS header
    DosHeader = (UINT32*)ImageBase;
    if (DosHeader[0] != 0x00905A4D) { // "MZ" signature
        Print(L"[HOOK] Invalid DOS header\n");
        return NULL;
    }
    
    // Get PE header offset from DOS header
    UINT32 PeOffset = *(UINT32*)(ImageBase + 0x3C);
    PeHeader = (IMAGE_FILE_HEADER*)(ImageBase + PeOffset + 4); // Skip "PE\0\0"
    
    // Check PE signature
    if (*(UINT32*)(ImageBase + PeOffset) != 0x00004550) { // "PE\0\0"
        Print(L"[HOOK] Invalid PE signature\n");
        return NULL;
    }
    
    // Get optional header
    OptHeader = (IMAGE_OPTIONAL_HEADER64*)((UINT8*)PeHeader + sizeof(IMAGE_FILE_HEADER));
    
    // Get section headers
    SectionHeader = (IMAGE_SECTION_HEADER*)((UINT8*)OptHeader + PeHeader->SizeOfOptionalHeader);
    
    Print(L"[HOOK] Number of sections: %d\n", PeHeader->NumberOfSections);
    
    // Search for OslArchTransferToKernel signatures in code sections
    for (i = 0; i < PeHeader->NumberOfSections; i++) {
        // Check if this is a code section
        if (SectionHeader[i].Characteristics & 0x20) { // IMAGE_SCN_CNT_CODE
            UINT8 *SectionBase = ImageBase + SectionHeader[i].VirtualAddress;
            Print(L"[HOOK] .text section %d: %.8a at 0x%lx, size 0x%x\n", 
                  i, SectionHeader[i].Name, (UINTN)SectionBase, SectionHeader[i].VirtualSize);
            UINT32 SectionSize = SectionHeader[i].VirtualSize;
            
            Print(L"[HOOK] Searching section %d: %.8a at 0x%lx, size 0x%x\n", 
                  i, SectionHeader[i].Name, (UINTN)SectionBase, SectionSize);
            
            // Search for OslArchTransferToKernel signatures
            for (j = 0; j < SectionSize - 0x30; j++) {
                Ptr = SectionBase + j;
                

                /* OslArchTransferToKernel Signature x1 */
                if (Ptr[0x00] == 0x33 && Ptr[0x01] == 0xf6 &&
                    Ptr[0x15] == 0x48 && Ptr[0x16] == 0x8d && Ptr[0x17] == 0x05 &&
                    Ptr[0x1c] == 0x48 && Ptr[0x1d] == 0x8d && Ptr[0x1e] == 0x0d &&
                    Ptr[0x23] == 0x0f && Ptr[0x24] == 0x01 && Ptr[0x25] == 0x10 &&
                    Ptr[0x26] == 0x0f && Ptr[0x27] == 0x01 && Ptr[0x28] == 0x19) 
                {
                    OslFunctionAddr = (VOID*)Ptr;
                    OslFunctionOffset = 14;
                    Print(L"[HOOK] Found OslArchTransferToKernel (Signature 1) at 0x%lx\n", (UINTN)OslFunctionAddr);
                    Print(L"[HOOK] Function offset: %d bytes\n", OslFunctionOffset);
                    break;
                }
                
                /* OslArchTransferToKernel Signature x2, this is working */
                if (Ptr[0x00] == 0x33 && Ptr[0x01] == 0xf6 &&
                    Ptr[0x17] == 0x48 && Ptr[0x18] == 0x8d && Ptr[0x19] == 0x05 &&
                    Ptr[0x1e] == 0x48 && Ptr[0x1f] == 0x8d && Ptr[0x20] == 0x0d &&
                    Ptr[0x25] == 0x0f && Ptr[0x26] == 0x01 && Ptr[0x27] == 0x10 &&
                    Ptr[0x28] == 0x0f && Ptr[0x29] == 0x01 && Ptr[0x2a] == 0x19) 
                {
                    OslFunctionAddr = (VOID*)Ptr;
                    OslFunctionOffset = 16;
                    Print(L"[HOOK] Found OslArchTransferToKernel (Signature 2) at 0x%lx\n", (UINTN)OslFunctionAddr);
                    Print(L"[HOOK] Function offset: %d bytes\n", OslFunctionOffset);
                    break;
                }
            }
            
            if (OslFunctionAddr != NULL) {
                // for (i = 0; i < 0x30; i++) {
                //     original_osl_transfer_bytes[i] = Ptr[i];
                // }
                __builtin_memcpy(original_osl_transfer_bytes, Ptr, 0x30);
                break; // Found it, stop searching
            }
        }
    }
    
    if (OslFunctionAddr != NULL) {
        // Print some bytes around the found location for verification
        Print(L"[HOOK] Bytes at found location:\n");
        for (i = 0; i < 48; i += 8) {
            Print(L"  +0x%02x: %02x %02x %02x %02x %02x %02x %02x %02x\n", i,
                  ((UINT8*)OslFunctionAddr)[i], ((UINT8*)OslFunctionAddr)[i+1],
                  ((UINT8*)OslFunctionAddr)[i+2], ((UINT8*)OslFunctionAddr)[i+3],
                  ((UINT8*)OslFunctionAddr)[i+4], ((UINT8*)OslFunctionAddr)[i+5],
                  ((UINT8*)OslFunctionAddr)[i+6], ((UINT8*)OslFunctionAddr)[i+7]);
        }
    }
    
    return OslFunctionAddr;
}


BOOLEAN CheckIfWinload(
    IN CONST VOID* ImageBase,
    IN UINTN ImageSize
) {
    Print(L"[HOOK] Checking if image is winload.efi...\n");
    if (ImageBase == NULL ) {
        Print(L"[HOOK] Invalid image base or size\n");
        Print(L"[HOOK] ImageBase: %p, ImageSize: %lu\n", ImageBase, ImageSize);
        return FALSE;
    }
    PIMAGE_NT_HEADERS64 NtHeaders = RtlpImageNtHeaderEx(ImageBase, ImageSize);
    if (NtHeaders == NULL) {
        Print(L"[HOOK] Failed to get NT headers\n");
        return FALSE;
    }

    PIMAGE_SECTION_HEADER Section = (PIMAGE_SECTION_HEADER)((UINT8*)NtHeaders + sizeof(UINT32) + sizeof(IMAGE_FILE_HEADER) + NtHeaders->FileHeader.SizeOfOptionalHeader);

    
    for (UINT16 i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {
        // Print(L"[HOOK] Section %d: Name: %.8a, VirtualSize: 0x%x, VirtualAddress: 0x%x, SizeOfRawData: 0x%x, PointerToRawData: 0x%x\n",
        //       i, Section[i].Name, Section[i].VirtualSize, Section[i].VirtualAddress,
        //       Section[i].SizeOfRawData, Section[i].PointerToRawData);
        Print(L"cercando le sezioni %d: ", i);
        Print(L"Name: %s ", Section[i].Name);
        if (StriStr(Section[i].Name, L".rsrc") != NULL) {
            Print(L"Trovata .rsrc section: %s\n", Section[i].Name);
            // iterate this section searching for "OSLOADER.XSL"
            UINT8* SectionData = (UINT8*)ImageBase + Section[i].PointerToRawData;
            UINT32 SectionSize = Section[i].SizeOfRawData;
            // for (UINT32 j = 0; j < SectionSize - sizeof("OSLOADER.XSL"); j++) {
            for (UINT32 j = 0; j < SectionSize - 24; j++) {

                if (StriStr((CHAR16*)&SectionData[j], L"OSLOADER") != NULL) {
                    Print(L"[HOOK] Detected winload.efi!\n");
                    return TRUE;
                }
            }
        }
    }
    return FALSE;
}
