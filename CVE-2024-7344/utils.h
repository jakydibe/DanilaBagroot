#include <efi.h>
#include <efilib.h>
#include <stddef.h>        
#include "arch.h"



typedef struct  {
    UINT16    Machine;
    UINT16    NumberOfSections;
    UINT32   TimeDateStamp;
    UINT32   PointerToSymbolTable;
    UINT32   NumberOfSymbols;
    UINT16    SizeOfOptionalHeader;
    UINT16    Characteristics;
}   PE_COFF_HEADER;

typedef struct {
    UINT16 Magic;
    UINT8  MajorLinkerVersion;
    UINT8  MinorLinkerVersion;
    UINT32 SizeOfCode;
    UINT32 SizeOfInitializedData;
    UINT32 SizeOfUninitializedData;
    UINT32 AddressOfEntryPoint;
    UINT32 BaseOfCode;
    UINT64 ImageBase;
    UINT32 SectionAlignment;
    UINT32 FileAlignment;
    UINT16 MajorOperatingSystemVersion;
    UINT16 MinorOperatingSystemVersion;
    UINT16 MajorImageVersion;
    UINT16 MinorImageVersion;
    UINT16 MajorSubsystemVersion;
    UINT16 MinorSubsystemVersion;
    UINT32 Win32VersionValue;
    UINT32 SizeOfImage;
    UINT32 SizeOfHeaders;
    UINT32 CheckSum;
    UINT16 Subsystem;
    UINT16 DllCharacteristics;
    UINT64 SizeOfStackReserve;
    UINT64 SizeOfStackCommit;
    UINT64 SizeOfHeapReserve;
    UINT64 SizeOfHeapCommit;
    UINT32 LoaderFlags;
    UINT32 NumberOfRvaAndSizes;
} PE_OPTIONAL_HEADER64;

typedef struct {
    UINT32 VirtualAddress;
    UINT32 Size;
} DATA_DIRECTORY;

typedef struct {
    UINT8  Name[8];
    UINT32 VirtualSize;
    UINT32 VirtualAddress;
    UINT32 SizeOfRawData;
    UINT32 PointerToRawData;
    UINT32 PointerToRelocations;
    UINT32 PointerToLinenumbers;
    UINT16 NumberOfRelocations;
    UINT16 NumberOfLinenumbers;
    UINT32 Characteristics;
} PE_SECTION_HEADER;



typedef struct {
	UINT16 Length;
	UINT16 MaximumLength;
	CHAR16* Buffer;
} UNICODE_STRING;


typedef struct {
	LIST_ENTRY InLoadOrderLinks;
	VOID* ExceptionTable;
	UINT32 ExceptionTableSize;
	VOID* GpValue;
	struct _NON_PAGED_DEBUG_INFO* NonPagedDebugInfo;
	VOID* DllBase;
	VOID* EntryPoint;
	UINT32 SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	UINT32 Flags;
	UINT16 LoadCount;
	union {
		struct {
			UINT16 SignatureLevel : 4;
			UINT16 SignatureType : 3;
			UINT16 Frozen : 2;
			UINT16 HotPatch : 1;
			UINT16 Unused : 6;
		} s;
		UINT16 EntireField;
	} u1;
	VOID* SectionPointer;
	UINT32 CheckSum;
	UINT32 CoverageSectionSize;
	VOID* CoverageSection;
	VOID* LoadedImports;
	union {
		VOID* Spare;
		struct _KLDR_DATA_TABLE_ENTRY* NtDataTableEntry;
	} u2;

	// Below fields are Win 10+ only
	UINT32 SizeOfImageNotRounded;
	UINT32 TimeDateStamp;
} KLDR_DATA_TABLE_ENTRY, *PKLDR_DATA_TABLE_ENTRY;


typedef struct {
	KLDR_DATA_TABLE_ENTRY KldrEntry;
	UNICODE_STRING CertificatePublisher;
	UNICODE_STRING CertificateIssuer;
	VOID* ImageHash;
	VOID* CertificateThumbprint;
	UINT32 ImageHashAlgorithm;
	UINT32 ThumbprintHashAlgorithm;
	UINT32 ImageHashLength;
	UINT32 CertificateThumbprintLength;
	UINT32 LoadInformation;
	UINT32 Flags;
} BLDR_DATA_TABLE_ENTRY, *PBLDR_DATA_TABLE_ENTRY;




extern VOID  *winload_base;      // just a declaration â€“ no storage here
extern UINTN  OslFunctionOffset; // or extern VOID *OslFunctionAddress;
extern UINT8 original_osl_transfer_bytes[0x30]; // buffer to store original bytes of OslArchTransferToKernel



STATIC CONST UINT8 SigBlStatusPrint[] = {
	0x48, 0x8B, 0xC4,								// mov rax, rsp
	0x48, 0x89, 0x48, 0x08,							// mov [rax+8], rcx
	0x48, 0x89, 0x50, 0x10,							// mov [rax+10h], rdx
	0x4C, 0x89, 0x40, 0x18,							// mov [rax+18h], r8
	0x4C, 0x89, 0x48, 0x20,							// mov [rax+20h], r9
	0x53,											// push rbx
	0x48, 0x83, 0xEC, 0x40,							// sub rsp, 40h
	0xE8, 0xCC, 0xCC, 0xCC, 0xCC,					// call BlBdDebuggerEnabled
	0x84, 0xC0,										// test al, al
	0x74, 0xCC										// jz XX
};


#define EFI_VBS_POLICY_GUID \
    {0x77fa9abd, 0x0359, 0x4d32, { 0xbd, 0x60, 0x28, 0xf4, 0xe7, 0x8f, 0x78, 0x4b }}



CHAR16 CharToUpper(CHAR16 c) {
    if (c >= L'a' && c <= L'z') {
        return c - (L'a' - L'A');
    }
    return c;
}


INTN
EFIAPI
StrniCmp(
	IN CONST CHAR16 *FirstString,
	IN CONST CHAR16 *SecondString,
	IN UINTN Length
	)
{
	if (FirstString == NULL || SecondString == NULL || Length == 0)
		return 0;

	CHAR16 UpperFirstChar = CharToUpper(*FirstString);
	CHAR16 UpperSecondChar = CharToUpper(*SecondString);
	while ((*FirstString != L'\0') && (*SecondString != L'\0') &&
		(UpperFirstChar == UpperSecondChar) &&
		(Length > 1))
	{
		FirstString++;
		SecondString++;
		UpperFirstChar = CharToUpper(*FirstString);
		UpperSecondChar = CharToUpper(*SecondString);
		Length--;
	}

	return UpperFirstChar - UpperSecondChar;
}

UINT8*
EFIAPI
FindOslFwpKernelSetupPhase1Base(
	IN CONST UINT8* AddressInFunction
	)
{
    UINT8 sigArr[] = { 0x48, 0x89, 0x4C, 0x24, 0x08, 0x55, 0x53, 0x56, 0x57, 0x41, 0x54,0x41};


    UINT8 pattern_length = sizeof(sigArr) / sizeof(sigArr[0]);

    UINT8 *Current = (UINT8*)((UINTN)AddressInFunction); // Align to page boundary

    for(int i = 0; i < 0x1000; i += 1) {
        UINT8 *Ptr = Current - i;
        for (int j = 0; j < pattern_length; j++) {
            if (Ptr[j] != sigArr[j]) {
                break;
            }
            if (j == pattern_length - 1) {
                return Ptr;
            }
        }
    }

    return NULL;

}



#define VGA_TEXT_BUFFER 0xB8000
#define VGA_WIDTH 80
#define VGA_HEIGHT 25

static UINT16 *vga_buffer = (UINT16*)VGA_TEXT_BUFFER;
static UINTN cursor_x = 0;
static UINTN cursor_y = 0;

// Simple puts function - just outputs a string to VGA buffer
VOID runtime_puts(CONST CHAR8 *str) {
    while (*str) {
        if (*str == '\n') {
            cursor_x = 0;
            cursor_y++;
            if (cursor_y >= VGA_HEIGHT) {
                cursor_y = VGA_HEIGHT - 1;
                // Simple scroll: move everything up one line
                for (UINTN i = 0; i < (VGA_HEIGHT - 1) * VGA_WIDTH; i++) {
                    vga_buffer[i] = vga_buffer[i + VGA_WIDTH];
                }
                // Clear last line
                for (UINTN i = (VGA_HEIGHT - 1) * VGA_WIDTH; i < VGA_HEIGHT * VGA_WIDTH; i++) {
                    vga_buffer[i] = 0x0700; // Black background, white text, space
                }
            }
        } else {
            if (cursor_x >= VGA_WIDTH) {
                cursor_x = 0;
                cursor_y++;
                if (cursor_y >= VGA_HEIGHT) {
                    cursor_y = VGA_HEIGHT - 1;
                }
            }
            
            UINTN pos = cursor_y * VGA_WIDTH + cursor_x;
            vga_buffer[pos] = 0x0700 | *str; // White on black + character
            cursor_x++;
        }
        str++;
    }
}




STATIC
PKLDR_DATA_TABLE_ENTRY
EFIAPI
GetBootLoadedModule(
	IN CONST LIST_ENTRY* LoadOrderListHead,
	IN CONST CHAR16* ModuleName
	)
{
	if (ModuleName == NULL || LoadOrderListHead == NULL)
		return NULL;

	for (LIST_ENTRY* ListEntry = LoadOrderListHead->Flink; ListEntry != LoadOrderListHead; ListEntry = ListEntry->Flink)
	{
		// This is fairly heavy abuse of CR(), but legal C because (only) the first field of a struct is guaranteed to be at offset 0 (C99 6.7.2.1, point 13)
		CONST PBLDR_DATA_TABLE_ENTRY Entry = (PBLDR_DATA_TABLE_ENTRY)BASE_CR(ListEntry, KLDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
		if (Entry != NULL && StrniCmp(Entry->KldrEntry.BaseDllName.Buffer, ModuleName, (Entry->KldrEntry.BaseDllName.Length / sizeof(CHAR16))) == 0)
			return &Entry->KldrEntry;
	}
	return NULL;
}


// Function to set VbsPolicyDisable NVRAM variable, thx claude
EFI_STATUS SetVbsPolicyDisable(EFI_SYSTEM_TABLE *SystemTable) {
    EFI_STATUS Status;
    EFI_GUID VbsPolicyGuid = EFI_VBS_POLICY_GUID;
    UINT8 VbsPolicyValue = 1;  // 1 = Disable VBS, 0 = Enable VBS
    
    Print(L"[VBS] Setting VbsPolicyDisable NVRAM variable...\n");
    
    // Set the VbsPolicyDisable variable
    // Attributes: EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS
    Status = uefi_call_wrapper(
        SystemTable->RuntimeServices->SetVariable, 
        5,
        L"VbsPolicyDisable",        // Variable name
        &VbsPolicyGuid,             // GUID
        EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS,
        sizeof(UINT8),              // Data size
        &VbsPolicyValue             // Data
    );
    
    if (EFI_ERROR(Status)) {
        Print(L"[VBS] ERROR: Failed to set VbsPolicyDisable variable (0x%lx)\n", Status);
        if (Status == EFI_SECURITY_VIOLATION) {
            Print(L"[VBS] Security violation - Secure Boot may be preventing variable modification\n");
        } else if (Status == EFI_OUT_OF_RESOURCES) {
            Print(L"[VBS] Out of resources - NVRAM may be full\n");
        }
    } else {
        Print(L"[VBS] Successfully set VbsPolicyDisable = %d\n", VbsPolicyValue);
        
        // Verify the variable was set correctly
        UINT8 ReadValue = 0;
        UINTN DataSize = sizeof(UINT8);
        Status = uefi_call_wrapper(
            SystemTable->RuntimeServices->GetVariable,
            5,
            L"VbsPolicyDisable",
            &VbsPolicyGuid,
            NULL,
            &DataSize,
            &ReadValue
        );
        
        if (!EFI_ERROR(Status)) {
            Print(L"[VBS] Verification: VbsPolicyDisable = %d\n", ReadValue);
        }
    }
    
    return Status;
}

// Function to load and execute the next bootloader
EFI_STATUS LoadAndExecuteImage(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable, CHAR16 *FileName) {
    EFI_STATUS Status;
    EFI_LOADED_IMAGE_PROTOCOL *LoadedImage;
    EFI_DEVICE_PATH_PROTOCOL *DevicePath;
    EFI_HANDLE NextImageHandle;
    
    // Get the loaded image protocol for the current image
    Status = uefi_call_wrapper(SystemTable->BootServices->HandleProtocol, 3,
                               ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID **)&LoadedImage);
    if (EFI_ERROR(Status)) {
        return Status;
    }
    
    // Create device path for the next bootloader
    DevicePath = FileDevicePath(LoadedImage->DeviceHandle, FileName);
    if (!DevicePath) {
        return EFI_OUT_OF_RESOURCES;
    }
    
    // Load the next bootloader image
    Status = uefi_call_wrapper(SystemTable->BootServices->LoadImage, 6,
                               FALSE, ImageHandle, DevicePath, NULL, 0, &NextImageHandle);
    if (EFI_ERROR(Status)) {
        return Status;
    }
    
    // Start the next bootloader
    Status = uefi_call_wrapper(SystemTable->BootServices->StartImage, 3,
                               NextImageHandle, NULL, NULL);
    
    return Status;
}

// just depth1 return address (used for getting winload.efi base)
VOID* GetReturnAddress(VOID) {
    return __builtin_extract_return_addr( __builtin_return_address( 1 ) );
}

EFI_STATUS
EFIAPI
FindPattern(
	IN CONST UINT8* Pattern,
	IN UINT8 Wildcard,
	IN UINT32 PatternLength,
	IN CONST VOID* Base,
	IN UINT32 Size,
	OUT VOID **Found
	)
{
	if (Found == NULL || Pattern == NULL || Base == NULL)
		return EFI_INVALID_PARAMETER;

	*Found = NULL;

	for (UINT8 *Address = (UINT8*)Base; Address < (UINT8*)((UINTN)Base + Size - PatternLength); ++Address)
	{
		UINT32 i;
		for (i = 0; i < PatternLength; ++i)
		{
			if (Pattern[i] != Wildcard && (*(Address + i) != Pattern[i]))
				break;
		}

		if (i == PatternLength)
		{
			*Found = (VOID*)Address;
			return EFI_SUCCESS;
		}
	}

	return EFI_NOT_FOUND;
}

// Function to find PE header by walking backwards from an address
UINT8* FindImageBaseFromAddress(VOID *Address) {
    UINT8 *Current = (UINT8*)((UINTN)Address & ~0xFFF); // Align to page boundary
    UINT32 *DosHeader;
    // PE_COFF_HEADER *PeHeader;
    
    Print(L"[HOOK] Searching for PE header starting from 0x%lx\n", (UINTN)Current);
    
    // Walk backwards page by page (4KB at a time)
    while ((UINTN)Current > 0x1000) {
        // Check for DOS header "MZ" signature
        DosHeader = (UINT32*)Current;
        if (DosHeader[0] == 0x00905A4D) { // "MZ" signature
            // Verify PE header
            UINT32 PeOffset = *(UINT32*)(Current + 0x3C);
            if (PeOffset < 0x1000) { // Sanity check
                // Check PE signature
                if (*(UINT32*)(Current + PeOffset) == 0x00004550) { // "PE\0\0"
                    Print(L"[HOOK] Found PE header at 0x%lx\n", (UINTN)Current);
                    return Current;
                }
            }
        }
        Current -= 0x1000; // Move back one page
    }
    
    Print(L"[HOOK] PE header not found\n");
    return NULL;
}



// Function to find OslArchTransferToKernel in the loaded image
VOID* FindOslArchTransferToKernel(VOID *ReturnAddress) {
    UINT8 *ImageBase;
    UINT32 *DosHeader;
    PE_COFF_HEADER *PeHeader;
    PE_OPTIONAL_HEADER64 *OptHeader;
    PE_SECTION_HEADER *SectionHeader;
    UINTN i, j;
    UINT8 *Ptr;
    VOID *OslFunctionAddr = NULL;
    
    // Find image base from return address
    ImageBase = FindImageBaseFromAddress(ReturnAddress);
    if (ImageBase == NULL) {
        Print(L"[HOOK] Failed to find image base from return address\n");
        return NULL;
    }

    winload_base = ImageBase;
    Print(L"[HOOK] winload_base: 0x%lx\n", (UINTN)winload_base);
    
    Print(L"[HOOK] Image Base found at: 0x%lx\n", (UINTN)ImageBase);
    
    // Check DOS header
    DosHeader = (UINT32*)ImageBase;
    if (DosHeader[0] != 0x00905A4D) { // "MZ" signature
        Print(L"[HOOK] Invalid DOS header\n");
        return NULL;
    }
    
    // Get PE header offset from DOS header
    UINT32 PeOffset = *(UINT32*)(ImageBase + 0x3C);
    PeHeader = (PE_COFF_HEADER*)(ImageBase + PeOffset + 4); // Skip "PE\0\0"
    
    // Check PE signature
    if (*(UINT32*)(ImageBase + PeOffset) != 0x00004550) { // "PE\0\0"
        Print(L"[HOOK] Invalid PE signature\n");
        return NULL;
    }
    
    // Get optional header
    OptHeader = (PE_OPTIONAL_HEADER64*)((UINT8*)PeHeader + sizeof(PE_COFF_HEADER));
    
    // Get section headers
    SectionHeader = (PE_SECTION_HEADER*)((UINT8*)OptHeader + PeHeader->SizeOfOptionalHeader);
    
    Print(L"[HOOK] Number of sections: %d\n", PeHeader->NumberOfSections);
    
    // Search for OslArchTransferToKernel signatures in code sections
    for (i = 0; i < PeHeader->NumberOfSections; i++) {
        // Check if this is a code section
        if (SectionHeader[i].Characteristics & 0x20) { // IMAGE_SCN_CNT_CODE
            UINT8 *SectionBase = ImageBase + SectionHeader[i].VirtualAddress;
            Print(L"[HOOK] .text section %d: %.8a at 0x%lx, size 0x%x\n", 
                  i, SectionHeader[i].Name, (UINTN)SectionBase, SectionHeader[i].VirtualSize);
            UINT32 SectionSize = SectionHeader[i].VirtualSize;
            
            Print(L"[HOOK] Searching section %d: %.8a at 0x%lx, size 0x%x\n", 
                  i, SectionHeader[i].Name, (UINTN)SectionBase, SectionSize);
            
            // Search for OslArchTransferToKernel signatures
            for (j = 0; j < SectionSize - 0x30; j++) {
                Ptr = SectionBase + j;
                

                /* OslArchTransferToKernel Signature x1 */
                if (Ptr[0x00] == 0x33 && Ptr[0x01] == 0xf6 &&
                    Ptr[0x15] == 0x48 && Ptr[0x16] == 0x8d && Ptr[0x17] == 0x05 &&
                    Ptr[0x1c] == 0x48 && Ptr[0x1d] == 0x8d && Ptr[0x1e] == 0x0d &&
                    Ptr[0x23] == 0x0f && Ptr[0x24] == 0x01 && Ptr[0x25] == 0x10 &&
                    Ptr[0x26] == 0x0f && Ptr[0x27] == 0x01 && Ptr[0x28] == 0x19) 
                {
                    OslFunctionAddr = (VOID*)Ptr;
                    OslFunctionOffset = 14;
                    Print(L"[HOOK] Found OslArchTransferToKernel (Signature 1) at 0x%lx\n", (UINTN)OslFunctionAddr);
                    Print(L"[HOOK] Function offset: %d bytes\n", OslFunctionOffset);
                    break;
                }
                
                /* OslArchTransferToKernel Signature x2, this is working */
                if (Ptr[0x00] == 0x33 && Ptr[0x01] == 0xf6 &&
                    Ptr[0x17] == 0x48 && Ptr[0x18] == 0x8d && Ptr[0x19] == 0x05 &&
                    Ptr[0x1e] == 0x48 && Ptr[0x1f] == 0x8d && Ptr[0x20] == 0x0d &&
                    Ptr[0x25] == 0x0f && Ptr[0x26] == 0x01 && Ptr[0x27] == 0x10 &&
                    Ptr[0x28] == 0x0f && Ptr[0x29] == 0x01 && Ptr[0x2a] == 0x19) 
                {
                    OslFunctionAddr = (VOID*)Ptr;
                    OslFunctionOffset = 16;
                    Print(L"[HOOK] Found OslArchTransferToKernel (Signature 2) at 0x%lx\n", (UINTN)OslFunctionAddr);
                    Print(L"[HOOK] Function offset: %d bytes\n", OslFunctionOffset);
                    break;
                }
            }
            
            if (OslFunctionAddr != NULL) {
                // for (i = 0; i < 0x30; i++) {
                //     original_osl_transfer_bytes[i] = Ptr[i];
                // }
                __builtin_memcpy(original_osl_transfer_bytes, Ptr, 0x30);
                break; // Found it, stop searching
            }
        }
    }
    
    if (OslFunctionAddr != NULL) {
        // Print some bytes around the found location for verification
        Print(L"[HOOK] Bytes at found location:\n");
        for (i = 0; i < 48; i += 8) {
            Print(L"  +0x%02x: %02x %02x %02x %02x %02x %02x %02x %02x\n", i,
                  ((UINT8*)OslFunctionAddr)[i], ((UINT8*)OslFunctionAddr)[i+1],
                  ((UINT8*)OslFunctionAddr)[i+2], ((UINT8*)OslFunctionAddr)[i+3],
                  ((UINT8*)OslFunctionAddr)[i+4], ((UINT8*)OslFunctionAddr)[i+5],
                  ((UINT8*)OslFunctionAddr)[i+6], ((UINT8*)OslFunctionAddr)[i+7]);
        }
    }
    
    return OslFunctionAddr;
}