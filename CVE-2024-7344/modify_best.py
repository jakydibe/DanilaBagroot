#!/usr/bin/env python3
"""
EFI XOR Encryption Script
Encrypts an EFI file by XORing each byte with 0xB3
Adds a custom header of 0x200 bytes, where:
  - Bytes 0–3:   ASCII “ALRM”
  - Bytes 4–7:   Little-endian length of encrypted data
  - Bytes 8–15:  Your original remaining_header
  - Bytes 16–(0x200−5): padding 0x00
  - Bytes (0x200−4)–0x1FF: CRC32 of the encrypted data
"""

import sys
import os
import struct
import zlib
import binascii

def compute_crc32(path, header_size=0x0, chunk_size=65536):
    crc = 0
    with open(path, 'rb') as f:
        # salta l'header
        f.seek(header_size)
        # leggi a blocchi per non saturare la memoria
        while True:
            chunk = f.read(chunk_size)
            if not chunk:
                break
            crc = binascii.crc32(chunk, crc)
    # binascii.crc32 può restituire numeri negativi in Py < 3.9, quindi normalizziamo
    return crc & 0xFFFFFFFF


def encrypt_efi(input_file, output_file):
    # Original custom header (excluding first 8 bytes)
    remaining_header = bytes([
        0x00, 0x02, 0x00, 0x00,
    ])

    xor_key = 0xB3

    # Read and encrypt
    with open(input_file, 'rb') as f:
        efi_data = f.read()
    encrypted_data = bytearray(b ^ xor_key for b in efi_data)
    encrypted_length = len(encrypted_data)

    print(f"Input file size: {len(efi_data)} bytes")
    print(f"Encrypted data length: {encrypted_length} bytes")

    # Compute CRC32 of the encrypted payload
    crc32_val = compute_crc32(input_file)
    print(f"Computed CRC32: 0x{crc32_val:08X}")

    # Build header
    header = b'ALRM'                                # ID
    header += struct.pack('<I', encrypted_length)   # length
    header += remaining_header                      # custom bytes
    header += struct.pack('<I',crc32_val)
    # Pad so that header total = 0x200, reserving last 4 bytes for CRC
    pad_len = 0x200 - len(header)
    if pad_len < 0:
        raise ValueError("Header fields exceed 0x200 bytes")
    header += b'\x00' * pad_len

    # Append CRC32 in little-endian
    #header += struct.pack('<I', crc32_val)

    # Sanity check
    assert len(header) == 0x200

    # Write out
    with open(output_file, 'wb') as f:
        f.write(header)
        f.write(encrypted_data)

    print("Encryption complete!")
    print(f"Output file: {output_file}")
    print(f"  - Header: 0x200 bytes")
    print(f"  - Encrypted data: {encrypted_length} bytes")

def main():
    if len(sys.argv) != 3:
        print("Usage: python3 efi_xor_crypt.py <input_efi> <output_file>")
        sys.exit(1)

    inp, outp = sys.argv[1], sys.argv[2]
    if not os.path.exists(inp):
        print(f"Error: '{inp}' not found.")
        sys.exit(1)
    if os.path.exists(outp):
        resp = input(f"Overwrite '{outp}'? (y/N): ")
        if resp.lower() != 'y':
            print("Aborted.")
            sys.exit(0)

    encrypt_efi(inp, outp)

if __name__ == "__main__":
    main()
